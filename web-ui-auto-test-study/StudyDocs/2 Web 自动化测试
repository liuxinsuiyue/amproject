Web自动化测试
  Selenium安装
    Selenium简介
        Web 应用程序的验收测试常常涉及一些手工任务，例如打开一个浏览器，并执行一个测试用例中所描述的操作。但是手工执行的任务容易出现操作人员人为的错误，也比较费时间。
        因此，尽可能将这些任务自动化，以消除人为因素。
        Selenium 帮助您自动化验收测试，通过构建更严格测试、从而软件更为可靠也更易于维护。
        Selenium 支持web浏览器的自动化，它提供一套测试函数，用于支持Web自动化测试。函数非常灵活，能够完成界面元素定位、窗口跳转、结果比较。
        具有如下特点：
            支持多浏览器 如IE、Firefox、Safari、Chrome、Android手机浏览器等。
            支持多语言   如Java、C#、Python、Ruby、PHP等。
            支持多操作系统 如Windows、Linux、IOS、Android等。
            开源免费 官网：http://www.seleniumhg.org/

        Selenium 是用于测试 Web 应用程序用户界面 (UI) 的常用框架。它是一款用于运行端到端功能测试的超强工具。您可以使用多个编程语言编写测试，并且 Selenium 是能够在一个或多个浏览器中执行这些测试。

    Selenium架构
        client（python/java/ruby等）-> selenium（Webdriver） -> driver（geckodriver/chromedriver/IEDriverServer等） -> browser
            在客户端完成Selenium脚本编写，将脚本传送给Selenium服务器，Selenium服务器使用浏览器驱动（driver）与浏览器（browser）进行交互
            client：每个语言都有自己的库，提供不同的 API 供用户去调用完成相关的自动化测试行为；这里调用有关 web 自动化的 API 到 selenium 的 server
            selenium：用于将接收到的请求传给浏览器的driver，实施调用，实际上 selenium 就是浏览器driver的一个封装
            driver：针对浏览器的一个驱动引擎，每个浏览器都有自己的驱动（一般由各个浏览器厂商提供），可以通过驱动浏览器的API来完成对应操作
            browser：浏览器
        Selenium 源代码：
            https://github.com/SeleniumHQ/selenium，[Selenium Client Driver]
            (https://seleniumhq.github.io/selenium/docs/api/py/)：
            Selenium WebDriver的Python语言实现。
        安装
           第一步  组件安装
               安装浏览器 ：web自动化，先装浏览器是必须的 Firefox、Chrome
               下载selenium 支持的浏览器driver，将浏览器驱动位置加入环境变量path  （？？？需要配置吗 ，看我电脑好像没有） GeckoDriver（Firefox）、ChromeDriver（Chrome）,WebDriver版本需要和浏览器的版本保持一致。
               安装selenium-client Driver（pip install selenium） ：安装到这步后就可以开始web自动化了,不同语言的根据需要进行安装，如Java的可以使用maven,目前建议使用稳定版本的3.141.59：
               安装selenium-ide : 新手入门，我在这里就不去演示了，需要入门了解的小伙伴可以查阅资料哈~
           第二步  ChromeDriver下载
               1）先去到selenium官网的下载中心http://www.seleniumhq.org/download/；往下翻，找到 ChromeDriver
               2）进去后找到与你当前Chrome浏览器版本对应的driver版本，下载对应系统的driver(需要梯子，如果没有继续往下看)


    Selenium核心组件
        Selenium IDE        IDE是Chrome和Firefox扩展插件，可以录制用户在浏览器中的操作 (入门录制工具 不常用，了解即可)
        Selenium Grid        Grid用于selenium分布式，你可以在多个浏览器和操作系统中运行测试用例（可操纵浏览器集群，也可操作App）
        Selenium WebDriver     WebDriver使用浏览器提供的api控制浏览器,就像用户在操作浏览器。学习的重点（目前主要使用的，依赖于drivers）

        其他组件
        Selenium RC(1.0才有 已弃用)包含Client LIbraries和Selenium Server
            Selenium 2.0 = Selenium 1.0 + WebDriver（主推，可以看做是RC的替代品）
            Selenium 3.0 = Selenium 2.0 - Selenium RC（Remote Control）
        selenium drivers (浏览器驱动，被webdriver client 所依赖)
    下载及安装
       第一种方式    pip
          pip install selenium
       第二种方式    pycharm自带方式安装
           安装selenium的前提是拥有python开发环境（推荐使用pycharm）
           selenium 是python的第三方库，可采用pycharm的自带方式安装
           菜单栏File->Settings进入配置页面 找到项目的project interpreter 添加中搜索Selenium后Install Package
           在python文件中编写代码，如果程序能够调起相应浏览器，说明安装成功 (见 test_unit2的test_seleniumwebdriver.py)



  Selenium IDE（录制你的第一个web 自动化测试用例 待后续学习）
    简介
        Selenium IDE可以录制测试步骤。它代码导出的风格不是PageObject模式，一般不怎么使用，更倾向于写代码做标准的功能测试。

    下载及安装
       启动IDE
          安装完成后，通过在浏览器的菜单栏中点击图标启动。
       Welcome Screen
       录制第一个测试用例
           第一步：创建新项目后，系统将提示为其命名，取名为 hogwarts_demo1。
           第二步：然后需要填写 URL（要录制测试脚本的网站 URL）。设置一次就可以在整个项目的所有测试中使用，这里使用的是 https://ceshiren.com/。
           第三步：完成设置后，将打开一个新的浏览器窗口，加载 URL 并开始录制脚本。在页面上的操作都将记录在 IDE 中。操作完成后，切换到 IDE 窗口并单击停止录制按钮。
           第四步：停止后，为刚录制的测试用例取名ceshiren_demo1
    管理测试
       Tests
       Suites
        进入suites管理界面
        添加新suites
        导出用例结构分析
            利用 Selenium IDE 导出 pytest 格式代码。
             导出用例代码如下： 这段代码就简单的实现了对浏览器简单的自动化

                #注释是由 Selenium IDE 生成的代码
                # Generated by Selenium IDE
                #导入可能用到的依赖
                import pytest
                from selenium import webdriver
                from selenium.webdriver.common.by import By

                class TestDemo():
                  #setup_module()只会在开始测试运行一次
                  def setup_method(self, method):
                    #初始化webdriver
                    self.driver = webdriver.Chrome()
                    self.vars = {}

                  #teardown_module()只会在结束测试运行一次
                  def teardown_method(self, method):
                  #关闭浏览器并关闭启动 ChromeDriver 时启动的 ChromeDriver 可执行文件
                    self.driver.quit()
                  #测试方法
                  def test_demo(self):
                    #访问网址
                    self.driver.get("https://ceshiren.com/")
                    #设置窗口大小
                    self.driver.set_window_size(1473, 866)
                    #点击操作
                    self.driver.find_element(By.LINK_TEXT, "所有分类").click()
                    self.driver.find_element(By.CSS_SELECTOR, "#ember201 .category-name").click()
                    #关闭当前窗口
                    self.driver.close()
        保存
            单击 IDE 右上角的 save 图标，输入项目的保存名称和地址
        回放
            选择想要回放的测试用例，单击 play 按钮，在 IDE 中回放测试。
        控件定位
            点击命令可查看操作所定位控件的信息

  selenium测试用例编写
    简介
        编写测试用例的优势就是可以应对更加复杂的场景以及更符合PageObject设计模式，可以编写出来更易于阅读，更便于维护代码等
    引入依赖
        from selenium import webdriver
    测试用例的流程
        测试用例是为了实施测试而向被测试的系统提供的一组集合，这组集合包含：测试环境、操作步骤、测试数据、预期结果等。
        注意：一条测试用例的最终结果只有一个：成功或者失败。
        三大核心要素为 ：标题 、步骤 、预期结果
            1、标题：是对测试用例的描述，标题应该清楚的表达测试用例的用例
            2、步骤：对测试执行过程进行描述
            3、预期结果：提供测试执行的预期结果，预期结果一般是根据需求得出，如果实际结果和预期结果一致则测试通过，反之失败。
       编写自动化测试用例
            首先是在代码的最上面导入了 Selenium 的包，其次是测试方法命名、测试步骤、断言。

            from selenium import webdriver

            def test_search():      # 测试的标题即 test_search
                driver = webdriver.Chrome()                                             # 创建一个Chromedriver的实例
                driver.get('https://www.baidu.com')                                     # 测试的步骤
                search = driver.find_element_by_id('su').get_attribute('value')         #
                assert search == "百度"  # 断言预期结果

  显示等待与隐式等待
    简介
        在实际工作中等待机制可以保证代码的稳定性，保证代码不会因为网速、电脑性能等条件的约束而影响运行结果。
        等待就是当运行代码时，如果页面的渲染速度跟不上代码的运行速度，就需要人为的去限制代码执行的速度。
        在做 Web 自动化时，一般要等待页面元素加载完成后，才能执行操作，否则会报找不到元素等各种错误，这样就要求我们在有些场景下加上等待时间。
        最常见的有三种等待方式：
            隐式等待（全局等待）
            显式等待（？？？我可以叫它条件等待吗，一直等着直到until条件符合后就不等 一直等着直到until_not条件不符合后就不等） 当隐式等待不起作用时就用到显示等待
            强制等待（死等）    当隐式等待 显示等待都不起作用时使用强制等待
        后面会一一介绍这三种模式的使用场景。

    隐式等待        self.driver.implicitly_wait(30)
        设置一个等待时间，轮询查找（默认 0.5 秒）元素是否出现，如果没出现就抛出异常。这也是最常见的等待方法。
        隐式等待的作用是全局的，是作用于整个 session 的生命周期，也就是说只要设置一次隐式等待，后面就不需要设置。如果再次设置隐式等待，那么后一次的会覆盖前一次的效果。
        当在 DOM 结构中查找元素，且元素处于不能立即交互的状态时，将会触发隐式等待。（实践学习，对于一些不能点击的情况，隐式等待不会等）

    显示等待        WebDriverWait(driver, 10).until(expected_conditions.element_to_be_clickable(By.TAG_NAME, "title"))
        显式等待是在代码中定义等待条件（expected_conditions库、其他库方法、自定义方法），触发该条件后再执行后续代码。使用 WebDriverWait 类中的 until() 和 until_not() 方法，就能够根据判断条件进行等待。
        程序每隔一段时间（默认为 0.5 秒）进行条件判断，如果条件成立，则执行下一步，否则继续等待，直到超过设置的最长时间。

        # 导入显示等待
        from selenium.webdriver.support.wait import WebDriverWait
        from selenium.webdriver.support import expected_conditions

        # 设置10秒的最大等待时间，等待 (By.TAG_NAME, "title") 这个元素点击
        WebDriverWait(driver, 10).until(
            expected_conditions.element_to_be_clickable((By.TAG_NAME, "title"))
        )
        这里通过导入 expected_conditions 这个库来满足显式等待所需的场景，但是有些时候的场景 expected_conditions 库并不能很好的解决，这个时候就需要通过自己写方法来满足特定场景。
        假设：要判断某个元素超过指定的个数，就可以执行下面的操作。
            示例：
            def ceshiren():
                # 定义一个方法
                def wait_ele_for(driver):
                    # 将找到的元素个数赋值给 eles
                    eles = driver.find_elements(By.XPATH, '//*[@id="site-text-logo"]')
                    # 放回结果
                    return len(eles) > 0
                driver = webdriver.Chrome()
                driver.get('https://ceshiren.com')
                # 显示等待10秒，直达 wait_ele_for 返回 true
                WebDriverWait(driver, 10).until(wait_ele_for)

    强制等待(硬性等待)      强制等待是使线程休眠一定时间。强制等待一般在隐式等待和显式等待都不起作用时使用。
          time.sleep(10)

    案例（见 test_wait.py）

  web控件定位与常见操作（selenium find_element）(脚本见test_find_element())
    简介
        在做 Web 自动化时，最根本的就是操作页面上的元素，首先要能找到这些元素，然后才能操作这些元素。
        工具或代码无法像测试人员一样用肉眼来分辨页面上的元素。
        那么要怎么来定位到这些元素，本章会介绍各种定位元素的方法。
    id          Selenium 自带 id 定位，可以通过元素的 id 属性进行定位，比如下面的代码：
       driver.find_element_by_id('site-logo')
    name        Selenium 自带 name 定位，可以通过元素的 name 属性进行定位，比如下面的代码：  注意：通常来说 name 属性与 id 属性在页面中唯一，推荐使用。
        driver.find_element_by_name('wd')
    xpath       XPath 是一个定位语言，英文全称为：XML Path Language，用来对 XML 上的元素进行定位，但也适用于 HTML。下面来看一个例子：
        1、首先寻找 id 为 form 的 form 元素，然后再寻找它的子元素 span，span 的 class 属性为 bg s_ipt_wr quickdelete-wrap，最后找 span 的子元素 input：
        driver.find_element_by_xpath ("//form[@id='form']/span[@class='bg s_ipt_wr new-pmd quickdelete-wrap']/input")
        2、下面的定位也可以找到这个 input，请注意，这里使用了双斜杠//，它可以找到子孙节点，而单斜杠/只能找到子节点：
        driver.find_element_by_xpath("//form[@id='form']//input[@id='kw']")
        XPath 表达式更多内容可参考下面表格：
            表达式	描述
            nodename	选取此节点的所有子节点。
            /	从根节点选取。
            //	从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。
            .	选取当前节点。
            ..	选取当前节点的父节点。
            @	选取属性。
            使用Xpath运算符定位，
                Xpath还支持运算符，如果元素的一个属性无法定位，需要使用多个属性时可以使用Xpath运算符将多个属性连接起来一起定位
                常用如下
                |       计算两个节点集     //book | //cd   返回所有拥有book和cd元素的节点集
                or      或               price=9.80 or price=9.70    如果price是9.80或9.70就返回true
                and     与               price>9.80 and price<9.90   如果price>9.80且<9.90就返回true       如"//div[(@class,top)= and contains(text(),)='']"
        如何检验 XPath 定位是否正确？可以使用 chrome 的检查模式 -> Console，输入$x('XPath 表达式')即可
    css_selector(待深入学习)
        XPath 可以定位绝大多数元素，但是它采用从上到下的遍历模式，速度并不快，而 css_selector 采用样式定位，速度要优于 XPath，而且语法更简洁：

        下面是 Selenium 使用 css_selector 的例子：
            css_selector 找到 class 属性为 active 的元素，然后 > 表示找 class 属性为 active 的元素的子节点
            driver.find_element_by_css_selector('.active>a')
        下表列出了常用的 css_selector 表达式的用法：
            表达式	描述
            .intro	class="intro" 的所有元素
            #firstname	id="firstname" 的所有元素
            a[target=_blank]	具有属性 target="_blank" 的所有 a 元素
            p:nth-child(2)	属于其父元素的第二个 p 元素
        使用 Chrome 的检查模式 -> Console 也可以在当前页面检测 css_selector 是否正确，输入$('css selector 表达式')即可：
    link
        link text
        partial link text
            元素中会出现文字，比如下面的分类，可以利用这段文字进行定位：
        driver.find_element_by_link_text('欢迎光临霍格沃兹测试学院')
            也可以采用部分匹配方式，不必写全：“欢迎光临”、“欢迎光临霍格沃兹测试学院”、“霍格沃兹”
        driver.find_element_by_partial_link_text('霍格沃兹测试学院')
            注意：partial_link_text 与 link_text 的区别：
                partial_link_text 不用写全，只需写部分即可，比如上面使用“霍格沃兹”即可匹配到“欢迎光临霍格沃兹测试学院”。
    tag_name
            DOM 结构中，元素都有自己的 tag，比如 input tag, button tag, anchor tag 等等，每一个 tag 拥有多个属性，比如 id, name, value class,等等。
            可以使用 tag 进行定位:
        driver.find_element_by_tag_name('input')
            什么时候使用tag name?当一个元素没有任何属性，或者想验证链接数量，可以通过tag_name定位这些链接
            注意：尽量避免使用 tag_name 定位元素，因为有大量重复的元素！
    class_name              可以通过元素的 class 属性值进行定位：
        driver.find_element_by_class_name('active')

    补充：Javascript 定位                                  ？？？本质还是css定位，javascript定位主要用在什么场景呢 ？
        js = "document.querySelector('.item-tt-link')"          内含css定位
        element = self.driver.execute_script(js)

    推荐使用
        ID/Name -> CSS Selector -> Xpath -> Link -> Class Name -> Tag Name
            ID/Name 是最安全的定位选项。根据 W3C 标准，它在页面中是唯一的，ID 在树结构中也是唯一的。
            CSS Selector 语法简洁，搜索速度快于 Xpath。
            XPath 定位功能强大，采用遍历搜索，速度略慢。
            link，class name， tag name：不推荐使用，无法精准定位。

    常见操作    （浏览器、页面、元素）
        输入、点击、清除            对应 Selenium 中的 send_keys、click、clear
            from selenium import webdriver

            driver = webdriver.Chrome()
            driver.get('http"//www.baidu.com')
            driver.find_element_by_name('wd').send_keys('霍格沃兹测试学院')         #输入
            driver.find_element_by_id('su').click()                              #点击
            driver.find_element_by_name('wd').clear()                            #清除
        获取元素属性               get_attribute('value')，元素的坐标 location，元素的大小 size
            import logging
            from selenium import webdriver

            def test_baidu():
                driver = webdriver.Chrome()
                driver.get('https://www.baidu.com')
                search = driver.find_element_by_id('su')                          #找到search元素
                logging.basicConfig(level=logging.INFO)
                logging.info(search.get_attribute('value'))                       #获取search的value属性值并打印 输出结果：INFO:root:百度一下
                logging.info(search.location)                                     #打印search的位置坐标         输出结果：INFO:root:{'x': 844, 'y': 188}
                logging.info(search.size)                                         #打印search的元素大小         输出结果：INFO:root:{'height': 44, 'width': 108}
        关闭窗口、浏览器            关闭当前句柄窗口（不关闭进程）close()，关闭整个浏览器进程 quit()

            from selenium import webdriver                      #导入对应的依赖

            driver = webdriver.Chrome()                         #初始化webdriver（实例化 线程）
            driver.get('http"//www.baidu.com')                  #访问网站
            driver.close()                                                        #关闭当前窗口
            driver.quit()                                                         #关闭浏览器
        获取网页源码、刷新页面       网页源代码 page_source，刷新页面 refresh()：

            import logging
            from selenium import webdriver

            driver = webdriver.Chrome()
            driver.get('http"//www.baidu.com')
            driver.refresh()                                                      #刷新页面
            logging.basicConfig(level=logging.INFO)
            logging.info(driver.page_source)                                      #打印当前页面的源代码
        设置窗口大小               最小化 minimize_window()，最大化 maximize_window()，设置窗口具体的大小 set_window_size(width,height)

            from selenium import webdriver

            driver = webdriver.Chrome()
            driver.get('http"//www.baidu.com')
            driver.minimize_window()                                              #最小化窗口
            driver.maximize_window()                                              #最大化窗口
            driver.set_window_size(1000, 1000)                                    #将浏览器设置为1000*1000的大小

  web控件的交互进阶  (selenium的ActiionChains 脚本见 test_seleniumwebdriver2.py)
    简介
        selenium中与浏览器交互就需要导入Action Chains，当需要模拟键盘or鼠标操作时，需要使用ActionChains来处理
            ActionChains的执行原理，当你调用ActionChains的方法时，不会立即执行，而是会将所有的操作按顺序存放在一个队列里，当你调用perform()方法时，队列中的时间会依次执行。
                可以是链式写法、分步写法
                链式写法
                    menu = driver.find_element_by_css_selector(".nav")
                    hidden_submenu = driver.find_element_by_css_selector(".nav #submenu1")
                    ActionChains(driver).move_to_element(menu).
                分步写法

    引入依赖    selenium.webdriver.common.action_chains.ActionChains(driver)
    点击相关操作（鼠标）
        单击
            action.click(on_element=None)          ——单击鼠标左键 如果元素不指定则单击当前鼠标的位置           也可以用selenium的element.click()来实现
            action.click_and_hold(on_element=None) ——点击鼠标左键，不松开，需要指定元素        ？？？举例个什么时候用的场景
            action.release(on_element=None)        ——释放按下的鼠标
        双击
            action.double_click(on_element=None)   ——双击鼠标左键
        拖拽
            action.drag_and_drop(source, target)   ——拖拽到某个元素然后松开(起始元素到目标元素)
            action.drag_and_drop_by_offset(source, xoffset, yoffset) ——拖拽到某个坐标然后松开（目标拖动到指定位置）
        鼠标右键
            context_click(on_element=None) ——点击鼠标右键

    按键          Keys.CONTROL 等
        按下
            key_down(value, element=None) ——按住某个键盘上的键，不放开
        松开
            key_up(value, element=None) ——松开某个键
        按下并立即松开
            send_keys(*keys_to_send) ——发送某个键到当前焦点的元素，可以输入多个
                焦点元素：使用tab键或者鼠标选定的元素
                模拟按键有多种方法，能用win32api，能用SendKeys来实现，也可以用selenium的element.send_keys()来实现
              action.send_keys_to_element(element, *keys_to_send)——向指定的元素输入数据

         举例
             ctrl+c                  ActiionChains(driver).key_down(Keys.CONTROL).send_keys(c).key_up(Key.CONTROL).perform()
             ctrl+shift+delete
             Fn+F12

    移动（鼠标移动/滚动）
        move_by_offset(xoffset, yoffset) ——鼠标从当前位置移动到某个坐标

        move_to_element(to_element) ——鼠标移动到某个元素         (最常用)
        move_to_element_with_offset(to_element, xoffset, yoffset) ——移动到距某个元素（左上角坐标）多少距离的位置

    其它
        action.perform()    将之前的一系列的ActionChains执行

  网页frame与多窗口处理（driver.switch_to.frame() driver.switch_to.parent_frame()    broswer.switch_to.window[handles[-1]] ）
    简介
        当我们要定位一个元素时，怎么都定位不到的时候要考虑是不是浏览器内嵌了一个frame窗口或者要找的元素在打开的窗口里。
        这时候就需要进行frame切换以及窗口的切换

        frame类似于在原有主html的基础上又嵌套一个html，而且嵌套的html是独立使用，互不影响
        当打开一个页面时，光标的定位是在主页面中，如果页面是由多个frame组成的，那么无法直接定位到具体的元素，需要切换到自己所需要的frame中，再查找该元素。
    iframe解析
        如图可以看到iframe的标签
    iframe的多种切换方式
        通过传入iframe标签的id name index webelement对象
        driver.switch_to.frame(0)               index 传入整型的参数，从0开始
        driver.switch_to.frame("hogwarts_id")   id 传入字符串的参数
        driver.switch_to.frame("hogwarts_name")   name 传入字符串的参数
        driver.switch_to.frame("driver.find_element_by_tag_name("ifram"))   name 传入字符串的参数
    iframe切换回默认页面
        driver.switch_to.default_content()

    iframe多层切换
        如果是多层嵌套的iframe（图见P47 iframe-iframe1-iframe2），
        从最外部iframe切换到iframe2则需要层层切换
            driver.switch_to.frame(iframe1)
            driver.switch_to.frame(iframe2)
        从里层切换到外层可以使用父子切换
            driver.switch_to.parent_frame()            iframe2切换回iframe1
            driver.switch_to.parent_frame()            iframe1切换到上一级iframe，如果iframe已经是最上级则保持不变

    多窗口处理(browser.window_handles)（脚本见test_seleniumwebdriver.py test_switchtowindow()）
            元素都有属性，浏览器的窗口其实也是有属性的，只是看不到，浏览器窗口的属性用句柄（handle）来识别。
            当一个浏览器打开一个窗口时，如果要在新的窗口操作就需要句柄切换。人为操作的话，可以通过眼睛看，识别不同的窗口点击切换。但是脚本只能句柄来判断要操作哪个窗口
       句柄的获取
            browser = webdriver.Chrome()
            handles = browser.window_handles
            print(handles)              当有多个句柄时，可以用window_handles 打印一下句柄，它是一个列表['CDwindow-E6B69492CE0DB1EB6ED25B5DE6D3883C', 'CDwindow-696DB1CBDFD47FC63943F963F4171737']
       句柄的切换
            browser.switch_to.window(handles[-1])       handles[-1]是一个数组？？ -1表示浏览器窗口的倒数第一个。
       实战案例（脚本见test_seleniumwebdriver.py test_switch_to_window()）
            百度搜索"霍格沃兹测试学院"，点击"霍格沃兹测试学员_腾讯课堂"，点击"中高级测试开发[名企定向培养]班_霍格沃兹学院"。

  多浏览器处理(脚本见test_seleniumwebdriver2.py test_browser() )
    通过对代码的的改造，实现自动化脚本对多浏览器的支持
    通过传递不同的参数测试不同的浏览器，用来实现浏览器的兼容性测试。
    注意：要先将各个浏览器的驱动配置好，具体的配置方式参考selenium安装章节
    将browser设置为环境变量，通过纯如环境变量的方式配置不同的浏览器

  执行JavaScript脚本(driver.execute_script() 脚本见test_javascript.py)
        当webdriver遇到无法完成的操作时候，这个时候可以使用javascript来完成，webdriver提供了execute_script()接口来调用js代码。
            执行js有两种场景：
                一种是在页面上直接执行js
                另一种是在某个已经定位的元素上执行js
    简介
        JavaScript是一种脚本语言，有的场景需要使用js脚本注入辅助我们完成selenium无法完成的事情。
    执行js
        selenium可以通过execute_script()来执行JavaScript脚本
            driver.execute_script:同步执行JavaScript在当前的窗口/框架下
            js脚本可以在浏览器的开发者工具->Console中进行调试（直接输入）

    js的返回结果
        获取元素中的属性值：
            document.querySelector(".item-tt-link").title
            document.querySelector(".item-tt-link").target
            document.querySelector(".item-tt-link").className
        与selenium结合，在代码中返回js结果
            # 获取网页性能的响应时间，js脚本中使用return代表返回获取的结果
            js = "return JSON.stringfy(performance.timing)"
            driver.execute_script(js)
    arguments传参
        # click()代表js中的点击动作， argument[0]代表所传值element的第一个参数
        element = driver.find_element(by,locator)
        driver.execute_script("argument[0].click();", element)

    实战案例
        以企业微信，使用浏览器复用的方法进行js点击添加图片的操作
        因为在企业微信上传文件需要登录，所以需要利用chrome的远程调试模式来复用登录后的浏览器。利用js来进行点击"添加图片"

  文件上传与弹窗处理
    简介
        在有些场景中，是需要上传文件，而selenium是无法定位到弹出的文件框以及网页弹出的提醒。这些都需要特殊的方式来处理。
        定义一个方法，通过execute_script执行js,js脚本中argument[0]代表所传值element的第一个参数，click()代表js的点击动作，element是传入的selenium.webelement对象，也就是定位到的元素
            def click_by_js(slf):
                element = driver.find_element(By.CSS_SELECTOR, "#js_upload_input")
                driver.execute_script("argument[0].click();", element)
    文件上传
        简单的input标签上传方式要使用自动化上传不难，先定位到上传按钮，然后send_keys把路径作为值给传进去
        如图所示，是企业微信文件上传的页面定位到标签为input，type为file的元素信息，并将突破路径以及文件输入到send_keys中
            driver.find_element(By.CSS_SELECTOR, "#js_upload_input").send_keys("./hogwarts.png")
        其他非input方式
            网上查相关资料 Sendkeys 第三方库  autoit
    其他常用的js脚本
        driver.execute_script("argument[0].removeAttribute('readonly');", element)  除掉元素只读属性
        driver.execute_script("argument[0].scrollIntoView(true)", element)  元素滚动至指定位置
        driver.execute_script('document.querySelector("#js_upload_input")''.style.display = "block";') 将元素属性由"none"改为"block"
    弹窗处理(待深入学习)
       alert弹框              点击确定
       confirm弹框            点击确定/取消
       prompt弹框             向弹框输入一段文本点击确定保存/点击取消不保存

  PageObject设计模式 博客园 2020年11月2日
    简介
        在为 UI 页面写测试用例时（比如 Web 页面，移动端页面），测试用例会存在大量元素和操作细节。
        如何面对当 UI 变化时，测试用例也要跟着变化这个问题？PageObject 设计模式闪亮登场（由 IT 大佬 Martin Flower 提出）。
        使用 UI 自动化测试工具时（Selenium、Appium 等），如果无统一模式进行规范，随着用例的增多会变得难以维护，
        而 PageObject 让自动化脚本井井有序，将 page 单独维护并封装细节，可以使 testcase 更稳健，不需要大改动。
    使用
        具体做法：把元素信息和操作细节封装到 Page 类中，在测试用例上调用 Page 对象（PageObject），
        比如存在一个功能“选取相册标题”，需要为之建立函数selectAblumWithTitle()，函数内部是操作细节findElementsWithClass('album')等：
            以选“取相册标题”举例，伪代码如下：
                selectAblumWithTitle() {
                    #选取相册
                    findElementsWithClass('album')
                    #选取相册标题
                    findElementsWithClass('title-field')
                    #返回标题内容
                    return getText()
                }
        PageObject 的主要原则是提供一个简单接口 (或者函数，比如上述的 selectAblumWithTitle )，让调用者在页面上可以做任何操作，点击页面元素，在输入框输入内容等。
        因此，如果要访问一个文本字段，Page Object 应该有获取和返回字符串的方法。
        Page Object 应该封装对数据的操作细节，比如查找元素和点击元素。当页面元素改动时，应该只改变 Page 类中的内容，不需要改变调用它的地方。

        不要为每个 UI 页面都创建一个 page 类，应该只为页面中重要的元素创建 page 类。比如，一个页面显示多个相册，应该创建一个相册列表 page object，它包含许多相册 page object。如果某些复杂 UI 的层次结构只是用来组织 UI，那么它就不应该出现在 page object 中。page object 的目的是通过给页面建模，从而对应用程序的使用者变得有意义：
        如果你想导航到另一个页面，初始 page 对象应当 return 另一个 page 对象，比如点击注册，进入注册页面，在代码中就应该 return Register()。如果想获取页面信息，可以 return 基本类型（字符串、日期）。
        建议不要在 page object 中放断言。应该去测 page object，而不是让 page object 自己测自己，page object 的责任是提供页面的状态信息。这里仅用 HTML 描述 Page Object，这种模式还可以用来隐藏 Java swing UI 细节，它可用于所有 UI 框架。
        具体案例（见）
  PageObject原则
    简介
        PageObject的核心思想是溜达原则，掌握六大原则才可以进行 PageObject 实战演练，这是PageObject的精髓所在。
        Selenium官方凝聚出了六大原则，后面的PageObject使用都将围绕六大原则开展：
            1 公共方法代表页面提供的服务
            2 不要暴露页面细节
            3 不要把断言和操作细节混用
            4 方法可以 return 到新打开的页面
            5 不要把整页内容都放到PO 中
            6 相同的行为会产生不同的结果，可以封装不同结果
        下面，对上述六大原则进行更详细的实操解释：
            原则一：要封装页面中的功能（或者服务），比如点击页面中的元素，可以进入到新的页面，于是，可以为这个服务封装方法“进入新页面”。
            原则二：封装细节，对外只提供方法名（或者接口）。
            原则三：封装的操作细节中不要使用断言，把断言放到单独的模块中，比如 testcase。
            原则四：点击一个按钮会开启新的页面，可以用 return 方法表示跳转，比如return MainPage()表示跳转到新的PO：MainPage。
            原则五：只为页面中重要的元素进行 PO 设计，舍弃不重要的内容。
            原则六：一个动作可能产生不同结果，比如点击按钮后，可能点击成功，也可能点击失败，为两种结果封装两个方法，click_success和click_error。

    案例
            以企业微信首页为例，企业微信首页有二个主要功能：立即注册和企业登录。
            企业微信网址：https://work.weixin.qq.com/
       Index页面
           点击企业登录可以进入登录页面，
           点击企业注册可以进入注册页面，
       Login页面
           在页面可以扫码登录和企业注册。
       Register页面
           在页面可以输入相关信息进行注册。

          用 Page Object 原则为页面建模，这里涉及三个页面：首页，登录，注册。在代码中创建对应的三个类Index，Login，Register：

              登陆页⾯  提供login findPassword 功能
                   -   Login类 + login   findPassword⽅法
              登录     页⾯内的元素有多少并不关⼼，隐藏内部界⾯控件
              登录成功和失败会分别返回不同的页⾯
                   - findPassword
                   - loginSuccess
                   - loginFail
              通过⽅法返回值判断登录是否符合预期

  UML图(图见书本P60)

    test_selenium.page.base_page.BasePage
        m __init__(self, driver:WebDriver = None)
        m close(self)
        f _driver
    test_selenium.page.index.Index
        m goto_register(self)
        m goto_login(self)
        f _base_url
    test_selenium.page.login.Login
        m scan_qrcode(self)
        m goto_registry(self)
    test_selenium.page.register.Register
        m register(self, corpname)
        m get_error_message(self)

  代码(代码见 test_uinit2/test_selenium_po)
    BasePage 是所有 page object 的父类，
        它为子类提供公共的方法，比如下面的 BasePage 提供初始化 driver 和退出 driver，
        代码中在 base_page 模块的 BasePage 类中使用 init 初始方法进行初始化操作，包括 driver 的复用，driver 的赋值，全局等待的设置（隐式等待）等等：
    Index 是企业微信首页的 page object，它存在两个方法，进入注册 page object 和进入登陆 page object，这里 return 方法返回 page object 实现了页面跳转，
        比如：goto_register方法return Register，实现从首页跳转到注册页：
    Register 是注册页面的 page object，主要功能是填写正确注册信息，当填写错误时，返回错误信息。
        register 方法实现了正确的表格填写，当填写完毕时返回自身（页面还停留在注册页）。
        get_error_message 方法实现了错误填写的情况，如果填写错误，就收集错误内容并返回：
    test_index 模块是对上述功能的测试，它独立于 page 类，
        在 TestIndex 类中只需要调用 page 类提供的方法即可，比如下面对注册页及登陆页的测试使用了 test_register 和 test_login 方法：