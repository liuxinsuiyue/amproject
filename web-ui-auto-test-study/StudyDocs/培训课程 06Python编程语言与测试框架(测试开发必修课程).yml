Python环境管理	安装多版本Python与IDE综合配置
  Python
    1990年python诞生
    2000年python2.0
    2008年 python3.0 3.0对2.0版本不太兼容
    2010年 python2.7（最后一个2.0版本）
    2020年 python 2.X正式退出历史舞台，只维护3.x版本 目前3.8是新版本

  Python安装
    官网下载安装包 找到适合系统的版本
    pkg 双击安装 默认下一步，安装完毕
    mac Linux会默认一个版本，比较老旧
    实际安装的版本在/usr/local/bin/可以查看
    创建短连接
    windows添加环境变量
    输入 python查看python的版本 进入交互式编程模式， exit（） 退出模式
      交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码。
      linux上你只需要在命令行中输入 Python 命令即可启动交互式编程
    脚本式编程
      Python 文件将以 .py 为扩展名
      命令运行程序：$ python test.py

    安装完之后需要重启

  PyCharm是一种python IDE，可以创建python文件和项目，带有一整套可以帮助用户使用Python语言开发时提高效率的工具
      调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等功能
    也可以支持Django框架下的专业web开发
    PyCharm安装
      官网下载安装 mac/windown/linux
      下载社区版就可以
      左侧历史项目，右侧可创建新项目
      。Location 设置工作空间并设置项目名称
      。项目编辑器可设置新的虚拟环境，避免依赖包版本影响其他版本；设置基本的编辑器（python版本）
      。项目下会显示虚拟环境文件
      项目下新增 Pythonfile 就是.py文件

  pip是python中的标准库管理器。它允许你安装和管理不属于Python标准库的其他软件包
    python3的3.4版本以及python2的2.7.9版本开始，pip被直接包括在python的安装包内

    python 社区活跃 类库丰富 自带sys os库等标准库
    数学、生物、图像、神经网络等 就需要引入已有的外界库
    pypi托管了大量非常流行的库 (www.pypi.org)
    pip install selenium完成安装
    pip uninstall selenium 卸载安装
    pip help查看用法
    pip <command> [optinos]
      例如
      install
      uninstall
      list
      show
      search
      help 等
      pip install selenium==版本号 加上==可以指定版本号
      pip install -i 镜像地址 --trusted-host 镜像地址对应的host
        举例：
          pip3 install jupyter -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com （后面要加一个信任镜像源）
        国内的pip源
          阿里云：https://mirrors.aliyun.com/pypi/simple/
          清华：https://pypi.tuna.tsinghua.edu.cn/simple
          豆瓣：http://pypi.douban.com/simple/

  Python 标识符（标识符可以标识类名、方法名、接口名、常量名等）
    在 Python 里，标识符由字母、数字、下划线组成。
    在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。
      Python 中的标识符是区分大小写的。
      以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。
      以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。
    关键字（特殊意义单词）和系统保留字（如函数、模块等的名字）不能做标识符

  Python 可以同一行显示多条语句，方法是用分号 ; 分开，如：
  >>> print ('hello');print ('runoob');

  行和缩进
    学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。
    缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。

  Python 可以使用引号( ' )、双引号( " )、三引号( ''' 或 """ ) 来表示字符串，引号的开始与结束必须是相同类型的。

  Python注释
    单行注释采用 # 开头。 （快捷键 ctrl+/）
    多行注释使用三个单引号(''')或三个双引号(""")(快捷键 三个引号+回车) 一般放在文件最顶上

Python基本数据类型与操作	Python的数字、字符串、列表的使用
  【变量】
    存储在内存中的值，这就意味着在创建变量时会在内存中开辟一个空间。是存储数据的载体 变量的值可以被读取和修改，这是所有计算和控制的基础 print（id(a)）打印变量存储地址 print(a)打印变量
    基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。
      因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。
      变量命名规则同python标识符 ，非硬性要求 见PEP8(简介、规范、易协作)
    等号 = 用来给变量赋值。

    常量、变量、字面量的区别
     int a;//a变量
     const int b=10;//b为常量,10为字面量
      常量和变量都属于变量，只不过常量是赋过值后不能再改变的变量，而普通的变量可以再进行赋值操作。
      Python3 的六个标准数据类型中：
        不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
        可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。
        string、list 和 tuple 都属于 sequence（序列）。
      Python有五个标准的数据类型：
        Numbers（数字）
        String（字符串）
        List（列表）
        Tuple（元组）
        Dictionary（字典）

  【数字】Number
    int（有符号整型）如10 -100
    long（长整型[也可以代表八进制和十六进制]），这个比较不常用 如-456788908L
    float（浮点型）如15.20 -21.9
    complex（复数）如9.322e-36j
    bool
    数学函数 常用的部分
      abs(x) 返回数字的绝对值
      ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5
      floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4
      max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。
      min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。
      sqrt(x) 返回数字x的平方根。

  【字符串】String
    表示文本的数据类型
    字符串或串(String)是由数字、字母、下划线组成的一串字符。

    用引号包起来
    python的字串列表有2种取值顺序:

      从左到右索引默认0开始的，最大范围是字符串长度少1
      从右到左索引默认-1开始的，最大范围是字符串开头

    截取子串：可以使用 [头下标:尾下标] 来截取相应的字符串，另外可以设置步长[start:stop:step]即[开始:结束:步长] 遵循左闭右开原则（尾下标是开的）

    举例：
      print(str)           # 输出完整字符串
      print(str[0])        # 输出字符串中的第一个字符
      print(str[2:5])      # 输出字符串中第三个至第六个之间的字符串
      print(str[2:])       # 输出从第三个字符开始的字符串
      print(str * 2)       # 输出字符串两次
      print(str + "TEST")  # 输出连接的字符串
      str_a = "aaa\\n"
      print(str_a)两个\ 会被打印出\n 如果改成一个\会打印出一个空行 注意转义字符
      str_a = r"aaa\n"  加r也能忽略转义符的作用
      print(str_a)

      Python字符串格式化（使用与 C 中 sprintf 函数一样的语法。）
      #!/usr/bin/python3
      print ("我叫 %s 今年 %d 岁!" % ('小明', 10))
      以上实例输出结果：
      我叫 小明 今年 10 岁!

      %d(整数) %c %x %f等等
  【列表】List
    List（列表） 是 Python 中使用最频繁的数据类型。[]标识 用逗号分隔开的元素列表
    列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。
    列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。
    另外可以设置步长[start:stop:step]即[开始:结束:步长] 得到的也是一个列表
    举例：
    #!/usr/bin/python
    # -*- coding: UTF-8 -*-

    list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
    tinylist = [123, 'john']

    print(list)               # 输出完整列表
    print(list[0])            # 输出列表的第一个元素
    print(list[1:3])          # 输出第二个至第三个元素，这个要注意下
    print(list[2:])           # 输出从第三个开始至列表末尾的所有元素
    print(tinylist * 2)       # 输出列表两次
    print(list + tinylist)    # 打印组合的列表

  【元组】Tuple
    元组是另一个数据类型，类似于 List（列表）。

    元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。
    举例：
    tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )
    list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
    tuple[2] = 1000    # 元组中是非法应用
    list[2] = 1000     # 列表中是合法应用

    1、与字符串一样，元组的元素不能修改。
    2、元组也可以被索引和切片，方法一样。
    3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。
    4、元组也可以使用+操作符进行拼接。

  【字典】Dictionary
    字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。

    两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。

    字典用"{ }"标识。字典由索引(key)和它对应的值value组成 用冒号分割，每个键值对之间用逗号分割。
    举例： 键名称要用引号括起来
    dict = {}
    dict['one'] = "This is one"
    dict[2] = "This is two"

    tinydict = {'name': 'runoob','code':6734, 'dept': 'sales'}


    print dict['one']          # 输出键为'one' 的值
    print dict[2]              # 输出键为 2 的值
    print tinydict             # 输出完整的字典
    print tinydict.keys()      # 输出所有键
    print tinydict.values()    # 输出所有值

  【数据类型转换】
    有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。

    如
    float(x)
    将x转换到一个浮点数
    str(x)
    将对象 x 转换为字符串
    repr(x)
    将对象 x 转换为表达式字符串
    tuple(s)
    将序列 s 转换为一个元组
    list(s)
    将序列 s 转换为一个列表
    dict(d)
    创建一个字典。d 必须是一个序列 (key,value)元组。  （）

  参考python官方参考文档
  进阶参考书籍
    《流畅的python》《python cookbook》

  Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字
    只要在文件开头加入 # -*- coding: UTF-8 -*- 或者 # coding=utf-8 就行了

    注意：Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。
    例如
    #!/usr/bin/python
    # -*- coding: UTF-8 -*-

    print( "你好，世界" )

    Pycharm 设置步骤：

      进入 file > Settings，在输入框搜索 encoding。
      找到 Editor > File encodings，将 IDE Encoding 和 Project Encoding 设置为utf-8。

  其他扩展

    import time
    time.time() 时间戳

    import time

    localtime = time.asctime( time.localtime(time.time()) )
    print "本地时间为 :", localtime

    本地时间为 : Thu Apr  7 10:05:21 2016

    我们可以使用 time 模块的 strftime 方法来格式化日期，：

    time.strftime(format[, t])
    # 格式化成2016-03-20 11:45:39形式
    print time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())

  Set（集合）
    基本功能是进行成员关系测试和删除重复元素。

    可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。

    创建格式：

    parame = {value01,value02,...}
    或者
    set(value)

Python控制流语法	条件、循环等表达式与流程控制
  Python语言支持以下类型的运算符:

    算术运算符 + - * / % **(幂) //(取整除)
    比较（关系）运算符== != <>（） > < >= <= Pyhton3 已不支持 <> 运算符，可以使用 != 代替
    赋值运算符= += -= *= /= %= **=（幂赋值运算符） //=
    逻辑运算符and or not
    位运算符 （把数字看作二进制来进行计算）&|^~<<>>
    成员运算符in   not in 字符串、列表、元祖
    身份运算符is   is not 引用同一个对象则true
    运算符优先级
      指数 (最高优先级)->按位翻转, 一元加号和减号->乘，除，取模和取整除->加法减法->右移，左移运算符->位 'AND'->位运算符-> 比较运算符->等于运算符->赋值运算符->身份运算符->成员运算符->逻辑运算符


    备注：Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可
    is 与 == 区别：

    is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。

  【条件】一条或多条语句的执行结果（True或者False）来决定执行的代码块  语句或语句组只会被执行1次
    关键字 ：缩进

    两种情况时如下：分支结构
      if 判断条件：
          执行语句…… 条件成立时
      else：
          执行语句……条件不成立时

    判定条件为多个值时如下： 多重分支
      if 判断条件1:
          执行语句1……
      elif 判断条件2:
          执行语句2……
      elif 判断条件3:
          执行语句3……
      else:
          执行语句4……条件不成立时

    分支嵌套 嵌套在if里或在else里
      if 判断条件：
          if 判断条件：
              执行语句…… 条件成立时
          else：
              执行语句……条件不成立时
      else：
          执行语句……条件不成立时
      两种都可以使用的时候尽量使用多重分支少用嵌套，代码可读性比较好
  循环 语句或语句组会被执行多次（for/while）

    【while循环】在某条件下（不知道循环次数），循环执行某段程序
      判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。
      当判断条件假 false 时，循环结束。
      while 判断条件(condition)：
          执行语句(statements)……

      while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，
      此外"判断条件"还可以是个常值，表示循环必定成立

      在 python 中，while … else 在循环条件为 false 时执行 else 语句块：
      实例
        #!/usr/bin/python

        count = 0
        while count < 5:
           print count, " is  less than 5"
           count = count + 1
        else:
           print count, " is not less than 5"

    【for循环】Python for in循环可以遍历任何序列的项目，如一个列表或者一个字符串（容器）。

      for iterating_var in sequence:
         statements(s)
      在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行 while也是一样的

      实例
        for letter in 'Python':     # 第一个实例
          print '当前字母 :', letter

        fruits = ['banana', 'apple',  'mango']
          for fruit in fruits:        # 第二个实例
             print '当前水果 :', fruit

          print "Good bye!"
        ----------------通过序列索引迭代
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-

        fruits = ['banana', 'apple',  'mango']
        for index in range(len(fruits)):
           print '当前水果 :', fruits[index]

        print "Good bye!"

    搭配range函数（产生一个不变的数值序列，而且这个序列通常都是用在循环中）
      range(101)可以产生一个0到100的整数序列
      range(1,100)可以产生一个1到99的整数序列，右边是开区间
      range(1,100,2)可以产生一个1到99的奇数序列，其中2是步长
    【嵌套循环】
      Python for 循环嵌套语法：

      for iterating_var in sequence:
         for iterating_var in sequence:
            statements(s)
         statements(s)

      Python while 循环嵌套语法：

      while expression:
         while expression:
            statement(s)
         statement(s)

      你可以在循环体内嵌入其他的循环体，如在while循环中可以嵌入for循环， 反之，你可以在for循环中嵌入while循环。
      以下实例使用了嵌套循环输出2~100之间的素数：

      实例
        #!/usr/bin/python
        # -*- coding: UTF-8 -*-

        i = 2
        while(i < 100):
           j = 2
           while(j <= (i/j)):
              if not(i%j): break
              j = j + 1
           if (j > i/j) : print i, " 是素数"
           i = i + 1

        print "Good bye!"
      【流程控制】
        break
          可以跳出for和while的循环体，任何对应的循环else块将不执行
        continue
          跳过当前循环块的剩余语句，继续下一轮
        pass
          不做任何事情，一般用做占位语句。

        # Fibonacci series: 斐波纳契数列
        # 两个元素的总和确定了下一个数
        a, b = 0, 1
        while b < 1000:
            print(b, end=',')
            a, b = b, a+b
        执行以上程序，输出结果为：

        1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,

        其中代码 a, b = b, a+b 的计算方式为先计算右边表达式，然后同时赋值给左边，等价于：

        n=b
        m=a+b
        a=n
        b=m

Python函数	函数定义、各类参数定义、Lamda表达式
  函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
  作用是封装
    函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。

  【函数定义】
    你可以定义一个由自己想要功能的函数，以下是简单的规则：

      函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。
      任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。
      函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。三个引号回车
      函数内容以冒号起始，并且缩进。
      return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 也可以以是数字或字符串

    语法
      Python 定义函数使用 def 关键字，一般格式如下：

      def 函数名（参数列表）:
          函数体

      函数体不能为空 参数没有在函数体重使用的话参数会置灰
  【函数调用】
    定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。

    这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。

    实例(Python 3.0+)
    #!/usr/bin/python3

    # 定义函数
    def printme( str ):
       # 打印任何传入的字符串
       print (str)
       return

    # 调用函数
    printme("我要调用用户自定义函数!")
    printme("再次调用同一函数")

  【各类参数】
    以下是调用函数时可使用的正式参数类型：

      1、必备参数 （位置参数）
        必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。


      2、关键字参数（在调用函数的时候使用k=v的形式传参）
        关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。
        使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。可避免多个参数的时候传参混乱
        关键字参数必须放在位置参数的后面
        例子printinfo( age=50, name="miki" )

      3、默认参数（在定义函数的时候使用k=v的形式定义）
        （默认参数的值如果没有传入，则被认为是默认值）定义的时候设值

        调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：
        例子 def printinfo(name, age=35):

      4、不定长参数（函数定义的时候使用）
        def functionname([formal_args,] *var_args_tuple ):
           "函数_文档字符串"
           function_suite
           return [expression]
        加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：
        在关键字参数前放置

        def func1(a,b,c,*,d):
            print("参数a的值",a)
        func1(10,1,0,-1)会报错
        * 后面的参数必须使用k=v的方式进行传参
        func1(10,1,0,d=-1)

  【Lamda表达式】
    使用lambda关键字来创建一个小的匿名函数
      主体是一个表达式 而不是一个代码块。仅能在lambda表达式中封装有限的逻辑进去
    代码更简洁 优雅
    实例
      变量承载(函数名)，参数，return值
      func2 = lambda x,y:x*y    定义
      print(func2(3,2))使用

    复杂逻辑还是要使用函数

  Python 内置函数
    详见官方文档 或 菜鸟教程
    https://www.runoob.com/python/python-built-in-functions.html

    Python map() 函数
      Python 内置函数 Python 内置函数
      参数
        function -- 函数
        iterable -- 一个或多个序列
      返回值
        Python 2.x 返回列表。
        Python 3.x 返回迭代器。

      描述
        map() 会根据提供的函数对指定序列做映射。
        第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。

      语法
        map() 函数语法：
        map(function, iterable, ...)
      实例：
        >>> map(square, [1,2,3,4,5])   # 计算列表各个元素的平方
        [1, 4, 9, 16, 25]
        >>> map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数
        [1, 4, 9, 16, 25]

        # 提供了两个列表，对相同位置的列表数据进行相加
        >>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])
        [3, 7, 11, 15, 19]

Python常用数据结构	列表、元组、集合、词典与常用便捷表达式（列表推导式）
  【列表】
    Python列表函数&方法
      Python包含以下函数:
        1 len(list)
        列表元素个数
        2 max(list)
        返回列表元素最大值
        3 min(list)
        返回列表元素最小值
        4 list(seq)
        将元组转换为列表

      Python包含以下方法:
        1 list.append(obj)
        在列表末尾添加新的对象
        2 list.count(obj)
        统计某个元素在列表中出现的次数
        3 list.extend(seq)
        在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
        4 list.index(obj)
        从列表中找出某个值第一个匹配项的索引位置
        5 list.insert(index, obj)
        将对象插入列表的指定位置
        6 list.pop([index=-1])
        移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
        7 list.remove(obj)
        移除列表中某个值的第一个匹配项
        8 list.reverse()
        反向列表中元素
        9 list.sort( key=None, reverse=False) False是升序排序，True是降序排序
        对原列表进行排序
        10 list.clear()
        清空列表
        11 list.copy()
        复制列表

    嵌套列表
      使用嵌套列表即在列表里创建其它列表
    Python列表截取与拼接
      列表对 + 和 * 的操作符与字符串相似。  + 号用于组合列表，* 号用于重复列表。
      列表都可以进行的操作包括索引，切片，加，乘，检查成员。
      访问列表中的值
      与字符串的索引一样，列表索引从 0 开始，第二个索引是 1，依此类推。

      通过索引列表可以进行截取、组合等操作。
      索引也可以从尾部开始，最后一个元素的索引为 -1，往前一位为 -2，以此类推。

      len([1, 2, 3])            3 长度
      [1, 2, 3] + [4, 5, 6]     [1, 2, 3, 4, 5, 6] 组合
      ['Hi!'] * 4               ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复
      3 in [1, 2, 3]            True 元素是否存在于列表中
      for x in [1, 2, 3]: print(x, end=" ") 1 2 3 迭代

      L[2] 'Taobao'             读取第三个元素
      L[-2] 'Runoob'            从右侧开始读取倒数第二个元素: count from the right
      L[1:] ['Runoob', 'Taobao'] 输出从第二个元素开始后的所有元素

      列表的特性
      list.clear()
      list.extend()
      list.index(x[,start[,end]])??
      list.count(x)
      list.copy()
      insert remove sort 只修改列表哦，没有打印出返回值，默认值none
  【列表推导式】
      概念：列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列

      实例
        相当于for

          list_square=[]
          for I in range(1:4):
              list_square.append(i**2)

          list_square2=[i**2 for I in range(1:4)]

        相当于for +if (for循环体内的if)

          list_square=[]
          for I in range(1:4):
              if i!=1
              list_square.append(i**2)

          list_square2=[i**2 for I in range(1:4) if i!=1]

        相当于for +for嵌套循环 (for循环体内的for)

          list_square=[]
          for I in range(1:4):
              for j in range(1:4):
              list_square.append(i*j)

          list_square2=[i*j for i in range(1:4) for j in range(1:4)]
  【元组】
    Python 的元组与列表类似，不同之处在于元组的元素不能修改。

    元组使用小括号 ( )，列表使用方括号 [ ]。

    元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。

    访问元组
      tup1 = ('Google', 'Runoob', 1997, 2000)
      tup2 = (1, 2, 3, 4, 5, 6, 7 )

      print ("tup1[0]: ", tup1[0])
      print ("tup2[1:5]: ", tup2[1:5])

    删除元组
      元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:
      del tup

    元组运算符
     与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。

      Python 表达式 结果 描述
        len((1, 2, 3))              3 计算元素个数
        (1, 2, 3) + (4, 5, 6)       (1, 2, 3, 4, 5, 6) 连接
        ('Hi!',) * 4                ('Hi!', 'Hi!', 'Hi!', 'Hi!') 复制
        3 in (1, 2, 3)              True 元素是否存在
        for x in (1, 2, 3): print (x,)  1 2 3 迭代

    内置函数
      1 len(tuple)
      计算元组元素个数。
      2 max(tuple)
      返回元组中元素最大值。
      3 min(tuple)
      返回元组中元素最小值。
      4 tuple(iterable)
      将可迭代系列转换为元组。

  【字典】
    字典是另一种可变容器模型，且可存储任意类型对象。

    字典的每个键值 key=>value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示：
      d = {key1 : value1, key2 : value2, key3 : value3 }
      键必须是唯一的，但值则不必。
      值可以取任何数据类型，但键必须是不可变的，如字符串，数字。

    创建字典：
      dict1 = { 'abc': 456 }
      dict2 = { 'abc': 123, 98.6: 37 }
      dict3 = dict{a=1,b=2}
    访问字典里的值
      把相应的键放入到方括号中，如下实例:
        print ("dict['Name']: ", dict['Name'])
        print ("dict['Age']: ", dict['Age'])
      如果用字典里没有的键访问数据，会输出错误如下：

    修改字典：增加新的键值对，修改删除已有键值对
      dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}

      dict['Age'] = 8               # 更新 Age
      dict['School'] = "菜鸟教程"  # 添加信息
      del dict['Name'] # 删除键 'Name'

      dict.clear()     # 清空字典
      del dict         # 删除字典

    字典内置函数&方法
      Python字典包含了以下内置函数：
        1 len(dict)
        计算字典元素个数，即键的总数。
        2 str(dict)
        输出字典，以可打印的字符串表示。
        3 type(variable)
        返回输入的变量类型，如果变量是字典就返回字典类型。
      Python字典包含了以下内置方法：
        1 radiansdict.clear()
        删除字典内所有元素
        2 radiansdict.copy()
        返回一个字典的浅复制
        3 radiansdict.fromkeys()
        创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
        如：b=a.formkeys({1,2,3},"a")
        4 radiansdict.get(key, default=None)
        返回指定键的值，如果键不在字典中返回 default 设置的默认值
        5 key in dict
        如果键在字典dict里返回true，否则返回false
        6 radiansdict.items()
        以列表返回可遍历的(键, 值) 元组数组
        7 radiansdict.keys()
        返回一个迭代器，可以使用 list() 来转换为列表
        8 radiansdict.setdefault(key, default=None)
        和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
        9 radiansdict.update(dict2)
        把字典dict2的键/值对更新到dict里
        10 radiansdict.values()
        返回一个迭代器，可以使用 list() 来转换为列表
        11 pop(key[,default])
        删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。
        12 popitem()
        随机返回并删除字典中的最后一对键和值。
      字典推导式：
        print（{i: i*2 for i in range(1,3)}）
        中间的推导式要用{}括起来
  【集合】
    集合（set）是一个无序的不重复元素序列。

    可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。

    它的基本用法包括成员检测和消除重复元素

    创建格式：
      parame = {value01,value02,...}
      或者
      set(value)
    实例
      >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
      >>> print(basket)                      # 这里演示的是去重功能
      {'orange', 'banana', 'pear', 'apple'}
      >>> 'orange' in basket                 # 快速判断元素是否在集合内
      True
      >>> 'crabgrass' in basket
      False
    # 下面展示两个集合间的运算.
      print(a - b)     # a 和 b 的差集
      print(a | b)     # a 和 b 的并集
      print(a & b)     # a 和 b 的交集
      print(a ^ b)     # a 和 b 中不同时存在的元素

    类似列表推导式，同样集合支持集合推导式(Set comprehension):

      实例(Python 3.0+)
        >>> a = {x for x in 'abracadabra' if x not in 'abc'}
        >>> a
        {'r', 'd'}

    集合的基本操作
      1、添加元素
        s.add( x )
          >>> thisset = set(("Google", "Runoob", "Taobao"))
          >>> thisset.add("Facebook")
        s.update( x )  参数可以是列表，元组，字典等
          >>> thisset = set(("Google", "Runoob", "Taobao"))
          >>> thisset.update({1,3})
          >>> print(thisset)
          {1, 3, 'Google', 'Taobao', 'Runoob'}
      2、移除元素
        s.remove( x ) 不存在会提示错误
          >>> thisset = set(("Google", "Runoob", "Taobao"))
          >>> thisset.remove("Taobao")
        s.discard( x ) 不存在不会发生错误
          >>> thisset = set(("Google", "Runoob", "Taobao"))
          >>> thisset.discard("Facebook")  # 不存在不会发生错误
      3、计算集合元素个数
        语法格式如下：
          len(s)
      4、清空集合
        语法格式如下：
         s.clear()
      5、判断元素是否在集合中存在
        语法格式如下：
          x in s
      add() 为集合添加元素
      clear() 移除集合中的所有元素
      copy() 拷贝一个集合
      difference() 返回多个集合的差集
      difference_update() 移除集合中的元素，该元素在指定的集合也存在。
      discard() 删除集合中指定的元素
      intersection() 返回集合的交集
      intersection_update() 返回集合的交集。
      isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。
      issubset() 判断指定集合是否为该方法参数集合的子集。
      issuperset() 判断该方法的参数集合是否为指定集合的子集
      pop() 随机移除元素
      remove() 移除指定元素
      symmetric_difference() 返回两个集合中不重复的元素集合。
      symmetric_difference_update() 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。
      union() 返回两个集合的并集
      update() 给集合添加元素"

Python横块	项目目录结构、模块定义、文件引用	"项目目录结构
  python的程序结构
    组成:
      package包
      module模块
      function 方法

    程序包：包括多个模块
    模块：包括函数、类、变量 来定义特殊的功能

    模块定义
      包含python定义和语句的文件
      .py文件
      作为脚本运行

  【总结】
    代码的可维护性
    提升编码效率
    函数名可重复（起名避免与系统重复）
  【模块导入】
    import 模块名
    from <模块名> import <方法|变量|类>
    from <模块名> import *
    注意：
      同一个模块写多次只被导入一次
      import应该放在代码的顶端

    【模块分类】
      1、系统内置模块
        安装完python语言后内置的（sys/os/time/re正则/time） 不需要安装
      2、第三方的开源模块
        pip install安装的模块
      3、自定义模块
        自己写的模块，对某段逻辑或某些函数进行封装后供其他函数调用
    当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。
      一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。

    import 语句
      想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：
      import module1[, module2[,... moduleN]
      from … import 语句

      Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：
      from modname import name1[, name2[, ... nameN]]

    from … import * 语句
      把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：
      from modname import *
       这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。

    __name__属性(待进一步理解)
      一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。

      #!/usr/bin/python3
      # Filename: using_name.py

      if __name__ == '__main__':
         print('程序自身在运行')
      else:
         print('我来自另一模块')

      说明： 每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。

      说明：__name__ 与 __main__ 底下是双下划线， _ _ 是这样去掉中间的那个空格。

  dir() 函数
    内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:（调试时常用，dir()不设参数代表查询当前模块，dir(sys)代表指定sys模块的所有名称）

    在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。（调试时常用，包名冲突时可以清晰看出来优先调用的是哪个包）

  【搜索路径】
    Python解析器 对模块位置的搜索位置是：
      1、包含输入脚本的目录（如果未指定文件，则为当前目录）
      2、pythonpath（目录名称列表，语法与shell变量相同path）
      3、安装的默认路径
      实际搜索路径以sys.path 顺序为准

      目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。
      最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。

      当我们执行模块代码时首先会加载__init__.py 定义的引入模块，然后进入__main__.py 文件运行

    示例
    sound/                          顶层包
          __init__.py               初始化 sound 包
          formats/                  文件格式转换子包
                  __init__.py
                  wavread.py
                  wavwrite.py
                  aiffread.py
                  aiffwrite.py
                  auread.py
                  auwrite.py
                  ...
          effects/                  声音效果子包
                  __init__.py
                  echo.py
                  surround.py
                  reverse.py
                  ...
          filters/                  filters 子包
                  __init__.py
                  equalizer.py
                  vocoder.py
                  karaoke.py
                  ...
    用户可以每次只导入一个包里面的特定模块，比如:
    import sound.effects.echo
    这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:

    sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
    还有一种导入子模块的方法是:

    from sound.effects import echo
    这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:

    echo.echofilter(input, output, delay=0.7, atten=4)

Python输入与输出	字面量打印与格式化、文件读取、Json格式转换
  【字面量literal】
    是以变量或常量给出的原始数据。在程序中可以直接使用字面量。

    字面量的类型：
    数值型
    字符型
    布尔型
    字面量稽核：列表（List），元组(Tuple)，字典（Dict）和集合（Set）
    特殊字面量：None
  【字面量插值】
    字面量插值，就是将变量、常量以及表达式插入的一种技术，它可以避免字符拼接的问题，很多语言都支持了此功能

    字面量插值方法：
    格式化输出
    通过string.format()方法拼接
    Formatted string literals,字符串格式化机制（>=python3.6） 可参考python官方文档
    还有其他方式，常用的有上面三种，重点了解最后一种，前两种
  【字面量插值】-格式化输出
    %的用法

    格式符为真实值预留位置，并控制显示的格式。格式符可以包含有一个类型码，用以控制显示的类型，如下:

      %s    字符串 (采用str()的显示)
      %r    字符串 (采用repr()的显示)
      %c    单个字符
      %b    二进制整数
      %d    十进制整数
      %i    十进制整数
      %o    八进制整数
      %x    十六进制整数
      %e    指数 (基底写为e)
      %E    指数 (基底写为E)
      %f    浮点数
      %F    浮点数，与上相同
      %g    指数(e)或浮点数 (根据显示长度)
      %G    指数(E)或浮点数 (根据显示长度)

      %%    字符"%"

    可以用如下的方式，对格式进行进一步的控制：
      %[(name)][flags][width].[precision]typecode
        (name)为命名

        flags可以有+,-,' '或0。+表示右对齐。-表示左对齐。' '为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。
        width表示显示宽度
        precision表示小数点后精度

      优点：可以指定格式
      缺点：必须指定正确类型后才能输出，不然会报错
    实例
      name='lily'
      age=20
      print('my name is %s,my age is %d,num is %.2f'%(name,age,3.14159))

  【字面量插值】-string.format()方法
    format（）方法
    用法：str.fomat()可以将
      字符串
      print("we are the {} and {} ".format('Tom','Jerry'))
      列表
      print("we are the {0} and {1}".format(*listdata))
      字典
      print("my name is {name},age is {age}".format(**dictdata))
      参数类型可以不一致
      print('my list is {list1},my dict is {dict1}'.format(list1,dic1))

    括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。

    在括号中的数字用于指向传入对象在 format() 中的位置，

  实例
    位置及关键字参数可以任意的结合:

    >>> print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))
    站点列表 Google, Runoob, 和 Taobao。

   {}中中的值缺省时，按位置参数顺序读取

  可选项 : 和格式标识符可以跟着字段名。允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：

  >>> import math
  >>> print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
  常量 PI 的值近似为 3.142。

  【字面量插值】-Formatted string literals,字符串格式化机制
  F-strings机制
  使用方法：f'{变量名}‘
  注意：
  大括号里面可以是表达式或者函数
  大括号内不能转移，不能使用’\‘

  实例：
  name =
  age =
  list1=
  dict1=
  print(f"my name is {name},age is (age),my list is {list1},my dict1 is {dict1}")

  print(f'my name is {name.upper()}')

  print(f'result is {(lambda:x:x+1)(2)}')
  :冒号等符号需要将表达式用括号括起来才不会报错"	"【文件读取】
  读取文件的操作步骤：
  第一步：打开文件，获取文件描述符
  第二步：操作文件描述符（读|写）
  第三步：关闭文件
  注意：
  文件读写操作完成后，应该及时关闭，释放资源，避免死锁

  Python open() 函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。
  注意：使用 open() 函数一定要保证关闭文件对象，即调用 close() 函数。

  open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。
  open(file, mode='r')
  完整的语法格式为：
  open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

  参数说明:

  file: 必需，文件路径（相对或者绝对路径）。
  mode: 可选，文件打开模式 只读r写入w追加a默认是只读r
  buffering: 设置缓冲 0不寄存 1访问文件时寄存行 >1存储区的缓冲大小 负值，寄存区的缓冲大小则为系统默认。
  encoding: 一般使用utf8
  errors: 报错级别
  newline: 区分换行符
  closefd: 传入的file参数类型
  opener:

  实例：
  f = open('test.txt','r')
  f.read()
  f.close()
  最有写法：

  with语句块，打开后自动关闭，注意缩进
  with.open('文件名称','r') as f:
      print(f.readlines())

  一般写法
  with.open('test.txt') as f:
      while True：
          line=f.readline()
          if line:
              print(line)
          else:
             break
  如果读取的是图片，则模式用rb
  代表是二进制

  open(filename, mode)
  filename：包含了你要访问的文件名称的字符串值。
  mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。
  不同模式打开文件的完全列表：

  模式 描述
  r读（默认） w写 x创建文件并写文件 a写追加文件
  b二进制模式 t文本模式（默认） +对磁盘进行更新（读和写）
  ------
  r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
  rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。
  r+ 打开一个文件用于读写。文件指针将会放在文件的开头。
  rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。
  w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
  wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
  w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
  wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
  a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
  ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
  a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
  ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。
  X创建文件并进行写操作"	"print(f.readlines())一次读取全部行
  print(f.readline())一次读取一行，下一次调用则读取下一行 （适合大文件读取）
  读取文件常用的方法：
  read()读取文件中的所有内容（缺点：当文件内容非常大，大于内存时，无法使用这个方法）
  readable() 判断文件是否可读
  readlines() 读取所有行的内容放到列表中
  readline()每次读取一行（包含结束符），返回的是一个字符串对象，保持当前行的内存

  print 默认输出是换行的(每打印一次就会出现一个空行)，如果要实现不换行需要在变量末尾加上逗号 ,。

  像if、while、def和class这样的复合语句， 首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组（代码块）。
  --------------------
  str = input("请输入：");
  print ("你输入的内容是: ", str)

  键盘输入这块是在那个板块有介绍

  【Json格式转化】前后台开发人员用的多，测试更多使用yaml
  Json是什么
  .轻量级的数据交换格式（其他统一的数据交换格式 xml protobuf yaml）
  友好、易于读写（比 xml protobuf更好）
  对机器友好，易于解析和生成
  由列表和字典组成的

  可以描述多维的数据

  使用场景
  生成：将对象生成为字符串，存入文件、数据库、在网络传输等
  解析：解析来自文件、数据库、网络传输的字符串成Python对象
  跨语言的数据交换：比如python和C/C++/java/javascript的数据交换

  json使用方式
  json.dumps(): 对数据进行编码。 python string 转化成Json object
  json.loads(): 对数据进行解码。 Json string 转化成python object（在本地使用）
  常用的几种方法
  json.dumps(python_obj)将数据类型转换成字符串 json类型变成字符串传输回去
  json.loads(json_string)把字符串转成json
  json.dump()把数据类型转换成字符串并存储在文件中
  json.load(file_stream)把文件打开，把里面的字符转成数据类型

  在j son 的编解码过程中，Python 的原始类型与 json 类型会相互转换，具体的转化对照如下：

  Python 编码为 JSON 类型转换对应表：
  Python---------- JSON
  dict ----------object
  list, tuple ----------array
  str ----------string
  int, float, int- & float-derived Enums---------- number
  True ----------true
  False ----------false
  None ----------null
  JSON 解码为 Python 类型转换对应表：
  JSON ----------Python
  object ----------dict
  array---------- list
  string---------- str
  number (int) ----------int
  number (real) ----------float
  true ----------True
  false ----------False
  null ----------None
  "	"【Json】
  JSON: JavaScript Object Notation(JavaScript JavaScript 对象表示法)
  JSON 是存储和交换文本信息的语法，类似 XML。
  JSON 比 XML 更小、更快，更易解析。

  JSON 实例
  {
      "sites": [
      { "name":"菜鸟教程" , "url":"www.runoob.com" },
      { "name":"google" , "url":"www.google.com" },
      { "name":"微博" , "url":"www.weibo.com" }
      ]
  }
  这个 sites 对象是包含 3 个站点记录（对象）的数组。
  第一层字典，第二层列表，第三层字典，字典里是key-value键值对"

Python错误与异常	语法错误与定位、异常捕获、异常处理、自定义异常	"错误：
  语法错误，逻辑错误，系统错误
  语法错误与定位、
  实例：
  “SyntaxError: invalid syntax（语法）” 的意思就是 语法错误；
  常见原因：
  python版本问题，路径问题，粗心问题：忘记在 if , elif , else , for , while , class ,def 声明末尾添加 冒号( : )；
  误将 = 当成 == 使用；在安装第三方模块时也有可能出现“SyntaxError: invalid syntax”这个问题，这时需要检查一些是否是在cmd窗口下安装，同时，要到python的安装目录里面，找到pip所在的目录里面进行安装；
  业务逻辑错误一般不会给提示
  系统错误：内存泄露等

  异常：
  语法和逻辑都是正常的，程序业务逻辑不完善引起的程序漏洞（如除数为0）bug，程序执行过程中出现的未知错误
  ZeroDivisionError:division by zero
  常见异常类型： 所有的异常都继承了baseexception 见官网
  除零异常 ZeroDivisionErro 分母为0
  名称异常 nameerror  如表达式使用的变量未定义
  索引异常  Indexerror 如列表只有三个元素，list1[3]就会出异常
  键异常 keyerror 字典读取时，键错误
  值异常 valueerror 预期是数字却给了个字符串的值
  属性异常 python常量属性
  等等

  异常与错误区别
  异常可以被捕获和处理
  错误一般是编码错误，逻辑错误，系统错误（避免）"	"
  如何避免以上异常
  程序上做一些处理 需要做很多的异常判断 但会导致代码逻辑比较不清晰
  因此使用异常捕获

  【异常捕获】（接住异常，不会抛出异常）
  try:
      print(div(1,0))
  except:
      print("这里有个异常")

  升级--拿到异常并对异常进行收集，收集之后存储到日志文件或数据库
  try:
      print(div(1,0))
  except ZeroDivisionError as e:
      print(e)
      print("这里有个异常")

  升级--语句还有其他类型异常 接收各种各样异常
  try:
      print(div(1,1))
      list1=[1,2,3]
      print(list1[3])
  except ZeroDivisionError as e:
      print(e)
      print("这里有个异常")
  except IndexError as e1:
      print(e1)
  好用法---baseexcetion是个基本异常类，exception继承了baseexception
  try:
      print(div(1,1))
      list1=[1,2,3]
      print(list1[3])
  except Exception as e:
      print(e)
      print("这里有个异常")
  try出异常后会跳出try，导致语句执行不完整，此时可以把一些必须执行的代码放在finally 无论是否有异常最后都会被执行,如下：
  try:
      print(div(1,1))
      list1=[1,2,3]
      print(list1[3])
      f=open("data.txt")
      f.readlines()
  except Exception as e:
      print(e)
      print("这里有个异常")
  finally:
      f.close()
  #通常文件的关闭操作放在finally"	"【异常捕获与异常处理】
  try:
     执行代码
  except:
      发生异常时执行的代码
  -------------
  try:
     执行代码
  except:
      发生异常时执行的代码
  finally:
     无论是否有异常最后都会被执行
  -------------
  try:
     执行代码
  except:
      发生异常时执行的代码
  else:
     没有异常时执行的代码
  #上面这种用法比较少
  -------------
  #手动触发异常 实例
  def set_age(num):
     if num<=0 or num >200:
        raise ValueError(f"值错误{num}")
     else:
        print(f"设置的年龄为：{num}")"	"【自定义异常】
  定义和实例
  class MyException(Exception):
      def_init_(self,msg):
          print(f"这是一个异常:{msg}")

  def set_age(num):
     if num<=0 or num >200:
        raise MyException(f"值错误{num}")
     else:
        print(f"设置的年龄为：{num}")

  set_age(-10)


  "	"异常/错误处理流程

  检测到错误->引发异常->捕获异常操作

  如果是拼写、配置等引起的错误，根据出错信息排查错误出现的位置进行解决
  如果是程序设计不完善引起的漏洞，根据漏洞的情况进行设计处理漏洞的逻辑

Python面向对象编程	类定义、方法定义、类变量、实例引用、实例变量
类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
方法：类中定义的函数。
类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
局部变量：定义在方法中的变量，只作用于当前实例的类。
实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。
继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
实例化：创建一个类的实例，类的具体对象。
对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。"	"python面向对象语言
面向过程C语言
面向对象 java C++ python等

两种编程思想

面向过程（做饭）
.一种以过程为中心的编程思想
.简单的事情

面向对象（造车）生产好的东西组装
.一种更符合我们人类思维习惯的编程思想
.面向对象开发就是不断的创建对象，使用对象，操作对象做事情
.复杂的事情

什么是面向对象
把每个事物都看成一个类别，是具体对象抽象出来的类别 想要特定功能的时候从类别中实例出来
语言层面，封装代码和数据
规格层面，对象是一系列可被使用的公共接口
从概念层面，对象是某种拥有责任的抽象

在编程的时候尽可能的去模拟真实的世界，按照现实世界中的逻辑去处理问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题

实际编程就是面向对象和面向过程的结合"	"【面向对象程序设计规则】

首先分析有哪些类
每个类有哪些属性和行为
类与类之间存在的关系

类 方法 类变量的定义

类：抽象的概念，一类事物
方法：类中定义的函数，对外提供的服务（接口）
类变量：类变量在整个实例化的对象中是公用的（类变量定义在类中且在函数体之外。）

实例变量：以‘self.变量名’的方式定义的变量

数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。
实例化：创建一个类的实例，类的具体对象。
方法重写（类-子类方法）：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
局部变量：定义在方法中的变量，只作用于当前实例的类。（？？？）
继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。"	"实例：
#'所有员工的基类' 通过class关键字定义了一个类
class Employee:
    #类变量
   empCount = 0
   #类中定义的方法要加一个self，不加的话运行的时候会报奇怪的错误
__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
        print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary"	"
  class Person：
   #类变量，同一个类具有的属性
    name = "default"
    age=0
    gender='male'
    weight=0
#一般不这么用，直接用__init__构造方法在实例化时初始化
    def set_param(self,name)
        self_name=name
        #self.name 是实例变量（每一个对象都有的属性）
    @classmethod
    def eat(self)
        print(f"{self.name}在吃")
    def play(self)
        print("玩")
    def jump(self)
        print("跳")
#实例引用、实例变量使用
zs=Person()
zs.set_param('zhangsan')
zs.set_age('20')
print(f"zhangsan 的姓名是：{zs.name},zhangsan的年龄是：{zs.age}")
内置方法--*--格式
用构造函数替代设置参数方法
   def __init__(self, name, age):
      self.name = name
      self.age = age
类的实例化例子：
zs=Person("zhangsan","20")
zs=Person("lisi","30")
zs.eat()
print(Person.name) 类变量，
print({zs.name}) 实例变量
实例变量和类变量都可以被修改，类变量通过类引用，实例变量是通过实例来访问
类方法不能访问，实例方法可以访问
类方法加一个装饰器@classmethod，就能被访问 类方法比较少用，一般在框架中使用（不需要对类进行实例化）
"	"类的继承
面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。

通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。

继承语法

class 派生类名(基类名)

import unittest

class MyTestCase(unittest.TestCase):
    def test_something(self):
        self.assertEqual(True, False)

if __name__ == '__main__':
    unittest.main()"	局部变量，前面加self.就变成实例变量
★实战|Python脚本编写实战	Python脚本编写实战	"环境问题
项目结构
Git 与 GitHub
python基本语法实战

----------------------
新手村入门

pyenv这个虚拟环境可以先不用，避免新手踩坑

命令行安装
pip install selenium
pip/pip3 不同的python版本使用的pip不一样，要注意一下

mac -> preference
windows -> settings  project interpreter选择存在的python环境
venv虚拟环境 用于环境隔离，不要在venv下面添加任何文件，不然会出现各种奇怪的报错

包和路径的区别
package __init__.py
directory  不能作为模块导入，只作为目录不作为包，new的时候要注意
"	"GitHub 公共世界用的大仓库
1、先去官网注册账号并登录，注册时需要填写邮箱
2、创建一个公有仓库 首页repository new 输入项目名称如 my_project 并增加描述 是外国网站，有时候网络比较不稳定
3、安装配置git
a.git官方网站下载对应系统的安装包， 安装完， 命令行-git验证下
b.git配置秘钥步骤
生成ssh-key：ssh-keygen -t rsa -C “your_email@youremail.com”（命令行输入，邮箱地址要跟github注册邮箱一致，然后一直按回车，然后根据页面提示的路径找到存放秘钥的路径） 打开文件或cat 可以查看秘钥
mac- ssh-key的位置：
windows：

配置ssh-key：找到id_rsa.pub ，复制到 github->Account->Settings->SSH and GPG keys
验证配置结果：ssh -T git@github.com（命令行输入）
c.设置username和email
    git config --global user.name “your name”
    git config --global user.email “your_email@youremail.com”
查看
    git config user.name
    git config user.email
d.把项目clone到本地:
    git clone github仓库名 （）
---------命令行结束
e.通过pycharm打开项目，github提交或pull 代码
git标志 绿色（勾）commit 加一下备注（最好把格式化代码选项勾上） 此时还没到仓库
VCS Git push 再点击push（绿色箭头）到仓库

pycharm的控制台 命令行输入 gitpull将代码更新到最新版本

gitlab一般是企业使用
补充：
github注册也可以在pycharm上完成，但功能不是很稳定，有时网络用不了
setting>github>输入用户名密码"	"实现一个回合制游戏：
函数
循环/判断
三目运算
类型提示
列表推导式


游戏解读
一个回合制游戏每个角色都有hp和power，hp代表血量，power代表攻击力，hp的初始值为1000，power的初始值为200。
顶一个一个fight方法：
my_hp=hp - enemy_power
enemy_final_hp= enemy_hp - my_power
两个hp进行对比，血量剩余多的人获胜"	"实现：game_round.py 函数+循环/判断
一回合

def fight():
    #定义四个变量
    my_hp=1000
    my_power=200
    your_hp=1000
    your_power=199
    """
        #一回合，一轮对打后的双方血量，
        my_final_hp=my_hp-your_power
        your_final_hp=your_hp-my_power

        if my_final_hp>your_final_hp:
            print("我赢了")
        elif my_final_hp<your_final_hp:
            print("我输了")
        else my_final_hp==your_final_hp:
            print("平局")

    """
    # 多回合，对比谁的血量为0谁输。 while True算法替代：
    # 先打的人占优势
    while True:
        my_hp=my_hp-your_power
        your_hp=your_hp-my_power
        if my_hp<=0:
              print("我输了")
              break
        elif your_hp<=0:
              print("你输了")
              break
# 调用fight()
fight()









"	"classCat：
   #属性
    name = "default"
    age=0
    gender='male'
    weight=0
#一般不这么用，直接用__init__构造方法在实例化时初始化
    def set_param(self,name)
        self_name=name
        #self.name 是实例变量（每一个对象都有的属性）
    @classmethod
    def eat(self)
    "	"【部分知识点】
实例化、
# 类在实例化的时候要加()
bike = Bicycle()
#调用传参
bike.run(100)

继承，
# 括号是父类，外面是子类，子类可以调用父类的方法，括号中只能填父类不嫩填参数
class EBicycle(Bicycle):

# 类属性，在类体内，方法之外
 # 属性需要参数传入对的时候需使用构造函数
 # 构造函数有设置参数，那实例化的时候需要传参
    def __init__(self,volume):
 # 属性前加self.才代表是类里的属性，才能在类里共用
 #实例属性，在类体内，方法之内，并且以“self.变量名”的方式，去定义的变量
        self.volume = volume
        # 普通属性，在类体内，方法之内，局部变量（我只在当前的方法内有用）
        # volume = volume
#调用父类的方法
第一种：和普通实例化类调用方法相同
    bike=Bicycle()
第二种：使用super 类似超级特权的意思
    super().run(km-e_km)
当子类中有和父类相同的类方法，先调用子类的

实际代码见路径E:\Git\MyProject\amproject\demo\bicycle.py"	"【使用面向对象实现回合制游戏】
class Game():
    def __init__(self,my_hp,my_power,your_hp,your_power):
        # 定义四个类属性，存放你我的血量还有攻击力
        self.my_hp=my_hp
        self.my_power=my_power
        self.your_hp=your_hp
        self.your_power=your_power

    def fight(self):
        # 多回合，对比谁的血量为0谁输。 while True算法替代：
        # 先打的人占优势
        while True:
            self.my_hp=self.my_hp-self.your_power
            self.your_hp=self.your_hp-self.my_power
            if self.my_hp<=0:
                  print("我输了")
                  break
            elif self.your_hp<=0:
                  print("你输了")
                  break

# 实例化并调用fight()
game=Game(1100,100,1200,100)
game.fight()







"	"【子类如何继承父类的构造方法】

    def __init__(self):
        # 继承父类的构造方法，解决同名覆盖问题，并且进行父类构造函数的传参
        super().__init__(1100,100,1200,100)
        self.defense=defense
houyi = HouYi(100)
---------------------------------
构造函数的时候
        super().__init__(houyi_hp,houyi_power,1200,100)

详细代码路径：
E:\Git\MyProject\amproject\demo\playgame_oo.py

模块化改造 将父类和子类通过两个文件夹的文件管理
import
from import 方法 常量
加入异常改造
当平局的时候抛出一个异常
        else:
            raise Exception("no peace,不要平局，战斗到最后一刻")"	"解决问题的多种方式
在python中，问题的定位
善用翻译工具
一个实战小练习

文件名、路径名、变量名、函数名、类名、不要和python内置库冲突，命名的时候最好加上_

python是根据缩进判定模块，所以要注意一下缩进
快捷键，往前缩进是shift+tab,往后缩进是tab

pycharm快捷键：
tab往后缩进，shift+tab往前缩进
ctr+D 复制当前行
快捷键导入模块： alt+enter
查看类、方法：ctr+鼠标点击
格式化代码 ctrl+alt+l
"	"标题
Python 脚本编写实战（一）

课程价值
掌握 python 环境搭建方法
掌握 git 和 github 使用方法
掌握 python 基础语法
大纲
环境问题
项目结构
Git 与 GitHub
python基本语法实战

脚本编写
应用
参考链接
git 下载地址：https://git-scm.com/downloads 14
github: https://github.com/ 9

python 环境安装
环境变量的配置：(装好环境变量后，需要重启)
Python和PyCharm环境安装配置 19
github 创建代码仓库

pycharm 安装git扩展插件
git 提交代码到github 需要两种免密方式
1、在pycharm 里面配置好 github的用户名和密码
2、ssh key ，将本地公钥配置到github上

变量和函数
1、python 允许在模块里定义 变量和方法的
2、函数里是可以调用外部的变量
3、函数里不允许改变外部变量
4、把外部变量设置为global 全局的，就可以改变它
5、通过 id() 方法可以打印对象的内存地址
6、方法默认返回值 是None

from … import 与 import 区别
1、 from…import 是复制了一份到本地
2、import … 是引用了变量的地址

pycharm 常用的快捷键
常用快捷键
格式化 alt + ctrl + L
导入 alt + 回车
复制当前行 ctrl +d
查看源代码 ctrl + 鼠标左键
注释，多行注释 ctrl + /
查找，替换 ctrl+f ,ctrl+r

课后作业
原有存款 1000元， 发工资之后存款变为2000元
定义模块
1、money.py saved_money = 1000
2、定义发工资模块 send_money，用来增加收入计算
3、定义工资查询模块 select_money，用来展示工资数额
4、定义一个start.py ，启动文件展示最终存款金额"
Python标准库	OS与文件处理、科学计算、网络访问、日期与时间等处理	"Python常用的标准库

Python标准库常见模块

操作系统相关：os
时间与日期：time,datetime
科学计算：math
网络请求：urllib
……"	"【os模块】
os模块主要是对文件、目录的操作
导入方式：import os
常用的方法：
os.mkdir() 创建目录 os.mkdir("testdir")
os.removedirs()删除文件os.removedirs("testdir")
os.getcwd()获取当前目录 print(os.getcwd())
os.path.exists(dir or file)判断文件或者目录是否存在 print(os.path.exists("testdir"))返回false代表目录不存在
os.listdir("./")当前目录下的所有文件 返回列表

实例 b目录/test.txt文件不存在就创建
import os
if not os.path.exists("b"):
    os.mkdir("b")
if not os.path.exists("b/test.txt"):
    f=open("b/test.txt","w")
    f.write("hello,os using")
    f.close()
--------
【操作系统接口】
os模块提供了不少与操作系统相关联的函数。

>>> import os
>>> os.getcwd()      # 返回当前的工作目录
'C:\\Python34'
>>> os.chdir('/server/accesslogs')   # 修改当前的工作目录
>>> os.system('mkdir today')   # 执行系统命令 mkdir
0
【文件通配符】
glob模块提供了一个函数用于从目录通配符搜索中生成文件列表:

>>> import glob
>>> glob.glob('*.py')
['primes.py', 'random.py', 'quote.py']
【命令行参数】
通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 "python demo.py one two three" 后可以得到以下输出结果:

>>> import sys
>>> print(sys.argv)
['demo.py', 'one', 'two', 'three']
【错误输出重定向和程序终止】
sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。

>>> sys.stderr.write('Warning, log file not found starting a new one\n')
Warning, log file not found starting a new one"	"【time模块】
获取当前时间以及时间格式间的模块
导入方式：import time
常用的方法
time.asctime()国外的时间格式
time.time() 时间戳
time.sleep()等待
time.localtime()时间戳转成时间元组
time.strftime()将当前的时间戳转成带格式的时间
格式：time.strftime("%Y-%m-%d %H-%M-%S",time.localtime())

实例 计算两天前的时间
import time

now_timestamp = time.time()
two_day_before = now_timestamp -60*60*24*2
time_tuple =time.localtime(two_day_before)
print(time.strftime("%Y-%m-%d %H:%M:%S", time_tuple))
time.strftime("%Y年%m月%d日 %H:%M:%S",time_tuple) 编码要设置成utf-8

1609729592.6732545
time.struct_time(tm_year=2021, tm_mon=1, tm_mday=4, tm_hour=11, tm_min=6, tm_sec=32, tm_wday=0, tm_yday=4, tm_isdst=0)

？？？tm_wday不准是为什么  0-6 0表示周日
datatime标准库是对time的二次封装

Python3 日期和时间
Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。
Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。
时间间隔是以秒为单位的浮点小数。
每个时间戳都以自从 1970 年 1 月 1 日午夜（历元）经过了多长时间来表示。--纪元

"	"【urllib】网络请求的库，
返回response的数据

python2
urllib2
使用：
import urllib2
response=urllib2.urlopen("https://www.baidu.com")

python3
封装到urllib.request里
使用：
import urllib.request
response = urllib.request.urlopen("https://www.baidu.com")

【requests】对urllib.request上一层的封装
是第三方库
"	"Python3 网络编程
Python 提供了两个级别访问的网络服务。：

低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。
高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
什么是 Socket?
Socket又称"套接字"，应用程序通常通过"套接字"向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。

socket()函数
Python 中，我们用 socket() 函数来创建套接字，语法格式如下：

socket.socket([family[, type[, proto]]])
参数
family: 套接字家族可以是 AF_UNIX 或者 AF_INET
type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM
protocol: 一般不填默认为0."	"【math库】
math.ceil(x) 数字的上入整数 大于或等于 x
math.fabs(x)数字的绝对值
math.floor(x)数字的下舍整数 小于或等于 x
math.sqrt(x)数字x的平方根
"
Python多线程处理	进程与多线程处理，Log处理	"【进程】
进程是执行中的程序
具有独立地址空间、内存、数据栈、追踪技术等，数据都是独立的
由操作系统统一管理
一个进程可以派生（fork或spawn）新进程（如bash执行awk 开启子进程来执行）
进程间通信（IPC）方式共享信息 （如bash管道符将两个进程之间进行通信）

多核CPU可以使用多进程，但进程之间通信会很困难
多进程之间是并行执行，同一个时刻会有10个进程进行
【线程】
同进程下执行，并共享相同的上下文 （数据共享）
线程间的信息共享和通信更加容易
多线程是并发执行（python） 对10个线程轮循进行，是交互的 ，其他语言可能会有可以支持并行的情况
需要同步原语（解决数据不同步的问题）锁 对信息进行加锁
"	"Python与线程

解释器主循环(没有编译过程，直接逐行运行，如果有10个.py文件同时运行时会开启10个线程，同一时间只有1个线程在执行)
主循环中只有一个控制线程在执行（执行时间太快 所以肉眼无法分辨）
使用全局解释器锁（GIL）

python两种线程管理
_thread:提供了基本的线程和锁
threading:提供了更高级别、功能更全面的线程管理（底层是_thread）
    支持同步机制
    支持守护进程

_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。

threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：

threading.currentThread(): 返回当前的线程变量。
threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。

run(): 用以表示线程活动的方法。
start():启动线程活动。
join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。
isAlive(): 返回线程是否活动的。
getName(): 返回线程名。
setName(): 设置线程名。"	"GIL保证一个线程的原理

设置GIL
切换进一个线程去执行
执行下面操作之一
    指定数量的字节码指令
    线程主动让出控制权
把线程设置回睡眠状态（切换出线程）
解锁GIL
重复上诉步骤"	"多线程的核心是多个线程同时操作，一定会造成数据的错误

原语 包括 锁（解决数据的互斥访问，只允许一个线程访问），信号量（新概念，比锁更灵活 不只是bool值，可以是0 1 2 3各种值）"	实例见demo工程
Python第三方库	常用的第三方库Pytest、Requests等	"【pytest】
类似python标准库的 unittest, 也是单元测试框架
selenium appium都会用到这个框架来测试 测试用例 测试数据管理 可以和allure生成很酷的测试报告
为什么不用unittest？ Pytest更灵活

安装&使用
命令行 pip install pytest


"	"【requests】
网络访问  python标准库的 urllib 更灵活，更方便的能够得到网络请求的数据

安装&使用
pypi查看最基本使用(安装、使用、特性)
官方文档可以看到详细使用
命令行 pip install request

使用语法：
import requests
r=requests.get(“https:www.baidu.com”)
r.status_code 200请求成功 404 500 505请求事变
r.encoding 编码 r.encoding=“utf-8”
r.text 返回文本

IDE下安装和使用
在env下安装 ，在project interpreter  左下角+ 输入名称
import requests
r=requests.get(“https:www.baidu.com”) get请求

r=requests.post(“https:www.baidu.com”,data={'key':'value'})post请求 传递url和数据

方法：相应内容r.text encoding link.json

=====================================================================================================

★实战|Python外部数据源文件处理	读取外部的YAML、JSon、Excel数据文件
  简介
    YAML是一个可读性高，用来表达数据序列化的格式，常常作为配置文件使用
    JSON是一个轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象
    EXCEL有直观的界面、出色的计算功能和图表工具是一款电子制表软件（计算机处理不太友好，但人为操作很强大）
  【Excel】
    落伍了，但有些公司会需要用来写用例，保存测试用例之类的
    http://www.python-excel.org/
    https://openpyxl.readthedocs.io/en/stable/
    使用语法：
    openpyxl 比较推荐（xlrd只支持.xls的读取，xlwr只支持.xls的写，xlutils包含读写，但加强版是openpyxl）
    安装：openpyxl第三方库
    范例1：将数据存储到一个新excel文件
       from openpyxl import Workbook
       import datetime

       wb = Workbook()
       # grab the active worksheet 获取当前活跃页签
       ws = wb.active
       # Data can be assigned directly to cells 单元格
       ws['A1'] = 42
       # Rows can also be appended 行
       ws.append([1, 2, 3])
       # Python types will automatically be convertedpython类型将自动转换

       ws['A2'] = datetime.datetime.now()
       # Save the file
       wb.save("sample.xlsx")
       ---------------
    范例2：将数据存储到一个新excel文件，在修改excel文件并保存
    from openpyxl import Workbook, load_workbook
    class PythonData:
        def create(self):
            wb = Workbook()
            ws = wb.active
            ws['A1'] = "身高"
            ws['B1'] = "体重"
            # # 身高
            self.height = [180, 160, 170, 155]
            # # 体重
            weight = [66, 50, 40, 30]
            for i in range(len(self.height)): # 循环要认清变与不变的东西，row行 column列
                ws.cell(row=2 + i, column=1, value=self.height[i])
                ws.cell(row=2 + i, column=2, value=weight[i])

            # Save the file
            wb.save("sample.xlsx")

        def health_weight(self):
            ld = load_workbook(filename="sample.xlsx")
            sheet = ld.active
            sheet["C1"] = "备注"
            for i in range(len(self.height)):
                height = sheet.cell(row=2 + i, column=1).value
                weight = sheet.cell(row=2 + i, column=2).value
                # 获取身高对应的健康体重
                health_w = (height-70)*0.6
                if weight == health_w:
                    print("这是健康的体重", weight)
                    sheet.cell(row=2 + i, column=3).value = "健康体重"

            ## 注意，一定要保存
            ld.save("sample1.xlsx")
    pd = PythonData()
    pd.create()
    pd.health_weight()

  【Json】python对象和json对象进行转换
      研发常用，尤其用在后端写返回值  支持字典，列表两种格式（同yaml）
      docs.python.org/3/library/index.html

      JSON的读写 不带s就是操作文件，带s就是操作字符串；序列化是python对象->字符串/文件，反序列化是字符串/文件->python对象
        json.dump
         序列化 是将python对象（dict类型，也可以是dict组成的list类型吧）转换为json格式字符串，存入文件
        json.dumps
         dumps得到一个字符串，是将python对象（dict，也可以是dict组成的list类型吧）转换为string(json格式字符串)
         （常用参数：sort_keys，输出是字典的是按键值排序的，而不是随机的。Ident，缩进，让我们更好的看清结构。）
        json.load
         反序列化，读取文件，是将json格式字符串转化为python对象（dict类型，也可以是dict组成的list类型吧）
        json.loads
         基于string，是将string转换为python对象（dict类型，也可以是dict组成的list类型吧）
      使用实例:

      dict_hogwarts = {
          "a" : [1,2,3],
          "name": ["sprider man", "星矢"]
      }
      # python object 数据 写到 data.json
       with open("data.json", "w") as f:
          json.dump(dict_hogwarts, f , ensure_ascii=False) ensure_ascii默认是True，此时中文会被转为ASCII码存到文件中
      # data.json 读到 python object 数据
      json_load = json.load(open("data.json"))  #？？？没有关闭文件的操作 这样对吗 ？
      print("使用json_load的数据为", type(json_load))

      自行练习 json.loads

     【YAML】python对象和yaml对象进行转换
        yaml是一个标记语言（一种注释文本的语言，以便计算机可以操作该文本）。与xml、ini一样，都可以用来做配置文件。
        强大的配置文件，包括运维（配docker K8）、 接口测试框架httprunner 用yaml描述测试用例
        官网介绍：https://pyyaml.org/wiki/PyYAMLDocumentation
        安装：pyyaml（pip install pyyaml）
          导入时包名是yaml 注意 避免踩坑
        yaml文件以 yaml或 yml结尾
        支持字典，列表两种格式（空格要注意），以下是yaml文件的编写：
          列表/序列（列表格式，前面加 - 字典的格式 key: value）不支持if else
            yaml里面写一个列表，前面加一个“-”符号: （-加空格 后面跟着变量名称，代表一个列表的元素）
            - admin1
            - admin2
            - admin3
            - [1,2,3] #元素也是支持直接写列表[1,2,3] 或 字典{a:1,b}，但一般
            ----------用缩进代表层级 #注释 从这个字符一直到行尾都会被解析器忽略，与python注释一致（cm实践：这个注释内容不能有中文，否则会报错）
            #这是个列表（这种放在真实项目中会报错）
            -
                - admin1
                - admin2
            - admin3
          字典 左侧代表key值，:后要加空格 后面跟着value，代表一个字典的元素，如果想要嵌套，需要用缩进代表属于谁，同一层级缩进相同，元素相同。可以加引号也可以不加引号，单引号双引号都可以
            person:
              -
                name: 小明
                age: 16
                habit: 吃饭
              -
                name: 小红
                age: 16
                habit: 吃饭
            animal:
              -
                name: cat
                age: 1
              -
                name: dog
                age: 11

          ----------------- 左侧都是- 代表是同一级的列表元素 左侧都是key代表是统同一级的字典元素


        YAML的读写
          yaml.dump
          yaml.load将yaml文件转换为python对象（官方不推荐使用）
          yaml.safe_load更加安全
        语法规则：
          大小写敏感，
          使用缩进表示层级关系，缩进空格数目不重要，只要相同层级的元素左侧对齐即可
        使用
          import yaml
          with open("data.yaml", "r") as f:
              yaml_data = yaml.safe_load(f)

          a = [[{'a': 1}, 'admin2'], 'admin3']
          with open("data3", "w") as f: #data3会自动存成.yaml格式文件
              yaml.safe_dump(a,f)


        实战案例-----------------
          class Game:
              def __init__(self):
                  # 定义四个变量，存放你和我的 血量还有攻击力，通过索引获取值
                  data = yaml.safe_load(open("game.yml"))
                  print(data)

                  self.my_hp = data["me"]["hp"]
                  self.my_power =  data["me"]["power"]

              def fight(self):
                  # 对打多轮，谁的血量先小于等于0，谁就输了
                  while True:
                      self.my_hp = self.my_hp - self.your_power
                      self.your_hp = self.your_hp - self.my_power
                      if self.my_hp<=0:
                          # pycharm 快捷键， ctrl+D 可以复制当前行
                          print("我的剩余血量为",self.my_hp)
                          print("你的剩余血量为",self.your_hp)
                          print("我输了")
                          break
                      elif self.your_hp <= 0:
                          print("我的剩余血量为",self.my_hp)
                          print("你的剩余血量为",self.your_hp)
                          print("你输了")
                          break

          game = Game()
          game.fight()




Python 脚本编写实战（二）

课程价值
掌握面向对象
掌握Yaml 用法
大纲
理解面向对象
面向对象实战
Yaml 用法
Yaml 实战

应用
参考链接
yaml 文档：https://pyyaml.org/wiki/PyYAMLDocumentation 8

面向对象
类是虚拟的、抽象的概念，没有具体的实体
实例是具体到某个事物
init() 方法给实例的属性赋值
私有属性和私有方法
私有的属性，不能通过对象直接访问，可以通过方法访问
私有的方法，不能通过对象直接访问
私有的属性、方法，不会被子类继承，也不能被访问
可以通过调用继承的父类的公有方法，间接的访问父类的私有方法、属性
dir(实例) 查看可被调用的属性和方法
self 的意思
1、self 只在类中定义的方法才有，类外面的函数是不需要有self参数的
2、self的名字不是必须的， 也不是关键词，
3、self 表示实例本身， 不是类
4、self的方法，需要实例去调用

数据存储格式
excel, csv, json, xml, yaml…

yaml 用法
安装 pyyaml

关键API

yaml.safe_load() 将yaml格式或者文件流转成 python 对象
yaml.safe_dump() 将python 对象转成yaml格式
语法规则
大小写敏感
使用缩进表示层级关系
缩进时不允许使用Tab键，只允许使用空格。
缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
#表示注释，从这个字符一直到行尾，都会被解析器忽略，这个和python的注释一样

课后作业
1、自己写一个面向对象的例子：

比如创建一个类（Animal）【动物类】，类里有属性（名称，颜色，年龄，性别），类方法（会叫，会跑）

创建子类【猫】，继承【动物类】，

复写父类的__init__方法，继承父类的属性，

添加一个新的属性，毛发=短毛，

添加一个新的方法， 会捉老鼠，

复写父类的‘【会叫】的方法，改成【喵喵叫】

创建子类【狗】，继承【动物类】，

复写父类的__init__方法，继承父类的属性，

添加一个新的属性，毛发=长毛，

添加一个新的方法， 会看家，

复写父类的【会叫】的方法，改成【汪汪叫】

调用 name== ‘main’：

创建一个猫猫实例

调用捉老鼠的方法

打印【猫猫的姓名，颜色，年龄，性别，毛发，捉到了老鼠】。

创建一个狗狗实例

调用【会看家】的方法

打印【狗狗的姓名，颜色，年龄，性别，毛发】。

2、将数据配置到yaml文件里"
Pip依赖管理与虚拟环境	第三方的依赖管理与项目管理	"【pip介绍】
pip是Python中的标准库管理。它允许你安装和管理不属于python标准库的其他软件包
Python3的3.4版本以及Python2的2.7.9版本开始，pip被直接包括在Python的安装包内
pypi托管了大量非常流行的库（www.pypi.org）
命令：
pip help 帮助
pip install 安装
pip install -U 包名 升级包
pip uninstall 卸载
pip list 列出所有的包文件
pip download 下载包
pip search requests 搜索包
安装包
pip install 包名==版本号(项目依赖版本)
举例 pip install selenium==2.39.0
pip install 包名 -i 镜像地址 --trusted-host镜像地址对应的host
举例 pip install jupyter -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
国内的pip镜像源
阿里云 https://mirrors.aliyun.com/pypi/simple/
清华https://pypi.tuna.tsinghua.edu.cn/simple
豆瓣http:pypi.douban.com/simple/"	"【虚拟环境】-命令行
https://docs.python.org/3/tutorial/venv.html

命令行 默认是指向默认python环境
pip安装是安装到默认的python环境下
如果需要创建虚拟环境，则在该python环境下执行
python3 -m venv tutorial-env
（mac内含bin/include/lib/pyvenv.cfg文件）
激活虚拟环境：
先进到虚拟环境的安装的路径，再执行激活指令
Windows
tutorial-env\Scripts\activate.bat

Unix or MacOS
source tutorial-env/bin/activate
关闭虚拟环境：
deactivate

删除虚拟环境
rm -rf tutorial-env"	"【虚拟环境】-pycharm管理
创建项目
创建的环境 虚拟环境
-可以指定虚拟环境路径，
-可以指定虚拟环境依赖的python环境
-可以设置是不是集成全局的环境（依赖包）
-应用于所有项目
使用系统的环境
-----------------
安装包
project interpreter 查找 install，manage可以配置镜像地址
pip安装包的时候，会同时安装它的依赖包

安装完可以在项目import进行验证
IDE工具在环境解析的时候可能出现问题，出现偶尔不能用的情况，可以使用命令行窗口进行验证"
PythonUnitTest测试框架	Python自带单元测试框架	"单元测试概述
什么是单元测试？
单元测试是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试是用于判定某个特定条件（或者场景）下某个特定函数的行为。  也就是通常说的白盒测试。
单元测试什么时候测试？开发完成后， 越早介入越好
单元测试由谁负责？开发人员
了解单元测试思想应用到后续测试
单元测试需要注意：
要清楚的知道测试的程序块所预期的输入和输出，然后根据这个预期和程序逻辑来写case。这里的预期结果一定要针对需求/设计的逻辑去写，而不是针对程序的实现去屑，否则单元测试就失去了意义，照着错误的实现设计出的case也很可能是错的。
----------------------
单元测试框架列举及国内大厂现状
Unittest
Python内置的标准类库。它的API和JUnit（Java）、NUnit(.net)、CppUnit(C++)很类似
Pytest
丰富、灵活的测试框架，语法简单，可以结合allure生成一个炫酷的测试报告，现在比较主流
Nose
是对Unittest的扩展，是的python的测试更加简单。
Mock
unittest.mock是用来测试pytho的库。这是一个标准库（出现在python3.3版本以后）"	"单元测试覆盖率
代码覆盖率
也被用于自动化测试和手工测试来度量测试是否全面的指标之一，应用覆盖率思想增强测试用例的设计()
单元测试覆盖类型：
语句覆盖
（运行测试用例时，被击中的代码即成为被覆盖的语句）if（a>1andb==0）if(a==2 or x>1)  a=3,b=0,x=4即可实现行覆盖 航覆盖是最基础的覆盖方式 也是最薄弱的
条件覆盖
 关注每个条件值的，足够全面，但测试用例数很多
判断覆盖
（运行测试用例时，被击中的判定语句）判定语句由多个条件组合而成，仅仅判断其整个最终结果（true/false），忽略每个条件的取值情况，必然会遗漏部分测试路径 上面例子只需要排列组合的4个数据即可完成
路径覆盖
覆盖所有可能的路径，也是测试用例设计时用的最多的方法

"	"unittest框架介绍，理解即可

测试框架组成
test fixture 测试装置，测试前和测试后要完成的操作
test case 测试用例
test suite 批量执行测试用例，组装
test runner 执行批量的测试用例
------------------------------
编写规范（IDE才能识别出来是测试用例，左侧会有运行标志）
测试模块首先import unittest
测试类要继承unittest.TestCase 类名称没有严格要求，建议Test开头驼峰命名法（pytest标准）
测试方法要以test_开头，方法内做断言
------------------------------
*setUp用来为测试准备环境，tearDown用来清理环境 每个测试方法开始和结束执行
所有case执行前准备环境和清理环境用。*setUpClass()与tearDownClass()，比如数据库连接及销毁（因为是类级别的方法，所以上面要加上@classmethod）整个类开始和结束执行
*如果想有些方法不在本次执行使用@unittest.skip
各种执行-单一用例，全部
-------------------------------
unittest断言--执行的每一步操作最好都有断言，断言的格式：相等 不相等 是否为True 是否为False等
常用断言语法 解释
assertEqual(a, b)  判断a==b 一般用作字符串比对
assertNotEqual(a, b) 判断a！=b
assertTrue(x) bool(x) is True
assertFalse(x) bool(x) is False
assertIs(a, b) a is b
assertIsNot(a, b)  a is not b
assertIsNone(x)  x is None
assertIsNotNone(x) x is not None
assertIn(a, b)  a in b
assertNotIn(a, b) a not in b
assertIsInstance(a, b) isinstance(a, b)
assertNotIsInstance(a, b)  not isinstance(a, b)"	"官网https://docs.python.org/3/tutorial/venv.html
unittest执行测试用例
编写unittest测试用例的原则
unittest会自动识别以test开头的函数是测试代码，test一定要是小写
执行测试用例的顺序
测试用例执行顺序是以test后面的字母顺序执行的。例如 test_a,test_b,test_c

import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
    unittest.main() #收集当前页面的所有测试用例
单元测试实例见test_unittest2.py（程序+单元测试程序）（cls）（self）有什么区别？？？"	错误日志时以堆栈的形式压栈，所以重点看最下方的错误提示	"执行测试用例
多个测试用例的集合就是测试套件，通过测试套件来管理测试用例，批量执行测试用例
方法一：
unittest.main()执行当前文件所有符合规范的unittest测试用例
方法二：执行指定的测试用例，添加到套件，批量执行
#创建测试套件
suite=unittest.TestSuite()
suite.addTest(TestMethod("test_01"))
suite.addTest(TestMethod("test_02"))
#一行只能添加一个方法？？类名，括号里时方法名
unittest.TextTestRunner().run(suite)

方法三：执行某个测试类或多个测试类
suite1=unittest.TestLoader().loadTestsFromTestCase(TestCase1)
suite2=unittest.TestLoader().loadTestsFromTestCase(TestCase2)
#一行只能添加一个类？？
suite=unittest.TestSuite([suite1,suite2])
unittest.TestTestRunner().run(suite)
方法四：匹配某个目录下所有以test开头的py文件，执行这些文件下的所有测试用例
test_dir="./test_case"
discover=unittest.defaultTestLoader.discover(test_dir,pattern="test*.py")
#发现某个目录下，符合规则的测试用例
discover可以一次调用多个脚本
test_dir被测试脚本的路径
pattern 脚本名称匹配规则
#然后跟testsuite一样运行测试用例
unittest.TextTestRunner(verbosity=2).run(discover)"	"if __name__ ==‘__main__’
这么写的原因是什么？后续解答（这个是Python解释器的入口函数）

测试用例执行过程
（1）首先时写好TestCase
（2）然后由TestLoader加载TestCase到TestSuite
（3）然后由TextTestRunner来运行TestSuite
（4）运行的结果保存在TextTestResult中
（5）整个过程集成在unittest_main模块中
TestCase可以是多个，TestSuit也可以时多个

unittest实战 结合htmlrunner生成测试报告

TextTestResult的分析 测试报告，反应测试工作量和业绩
unittest结合第三方工具htmltestrunner生成带日志的测试报告（了解即可）
最low的版本，不美观，但很多公司在用，作为入门
htmltestrunner分两个版本，Python2和Python3
Python3的使用
开源的工具都可以在github上面查看开源的代码，借鉴下别人的写法和代码结构，如何使用框架的说明
代码核心文件.py(对运行结果的收集以及绘制成图表)+readme（给了demo）+test.py样例定义测试模块
核心文件放到工程的util目录下可以被直接导入使用
with.open(report_file,'wb') as report:
    runner=HTMLTestRunner(stream=report,title=report_title,decription=desc)
runner.run(testsuite)
测试报告只能反映当前用例执行的情况，测试走势图得将结果保存下来并做二次定制才能看清走势，allure就能解决这个问题"	"


"
Pytest测试框架	Python最流行的全能型测试框架	"全功能的Python测试工具，与Python自带的unittest测试框架类似，但更简洁和高效，兼容unittest框架
支持简单的单元测试， 结合requests实现接口测试，结合selenium appium实现自动化功能测试，结合allure集成到Jenkins中实现持续集成  工作中一般会使用持续集成来完成代码集成到主干分支之后的回归测试，通过自动化测试的手段来实现产品的快速迭代

单元测试、代码测试
后面web，app,接口以pytest为基础，所有自动化课程都在用pytest
python界比较主流的单元测试框架，unittest pytest nose
入门难度低，第三方库丰富性，通用性，与allure生成的报告非常的美观
为编写测试用例规定了一些准则
------------------------
单元测试框架
web  app 接口测试都是基于Pytest进行用例管理
简单灵活，容易上手
支持参数化、支持测试用例的skip、标注和xfail自动失败重试等处理
能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试，接口自动化测试（pytest+request）;
pytest具有很多第三方插件，并且可以自定义扩展，比较好用的如pytest-allure（完美html测试报告生成），pytest-xdist(多CPU分发)等；
可以很好的和Jenkins集成
官方文档：https://docs.pytest.org/en/latest/contents.html#toc（用法）
第三方库：pypi.org搜索pytest"	"安装
pip install -U pytest
查看版本
pytest --version
------------------------------
用例识别与运行
-用例编写规范
测试文件以test_开头或_test结尾
测试类以Test_开头，并且不能带init方法（会被定为有特殊功能的类）
测试函数以test_开头
断言使用基本的assert即可
-运行参数
pytest --help
pytest 或者 py.test（老版本）
读取路径厦所有符合规则的文件，类，方法，函数全部执行
pytest -v
打印详细运行日志，一般调试的时候加上这个参数，终端会打印出没调用例的详细信息，方便定位问题
pytest -s
带控制待输出结果，运行时会打印出代码里面有print输出的代码，一般调试的时候加上这个参数
python-k '类名' 跳过运行类 用例
python-k ‘方法名’跳过运行方法 用例
python-k ‘类名 and not 方法名’跳过运行类里所有的方法，不包含某个方法
python -x 遇到用例失败立即停止运行 开发人员提测，运行用例存在未通过则打回开发人员
pytest --maxfail=[num] 用例失败个数达到阈值停止运行 使场景如上
pytest-m [标记名] 运行所有@pytest.mark.[标记名]这个标记的测试用例（pytest -m "add or div"
用来运行多标签场景，mac可以用单引号，Windows得用双引号 不然会报错）
运行模式
python 文件名.py  运行某个python文件
python 文件名.py::类名 运行给某个文件中的类
python 文件名:py::类名::方法名 执行类中某个方法
其他常用的执行参数
pytest --collect-only 只收集用例
pytest --junitxml=./result.xml 生成执行结果文件
pytest --setup-show 回溯fixture的执行过程
------------------------------
在Pycharm中运行pytest用例
设置->Tools->Python Integrated Tools->Testing:pytest
需要新安装python 可以在设置页面 点击“fix”，也可以直接在Projectinterpreter里添加pytest依赖包 安装完后符合用例规则的都能被识别出来并且标出一个绿色的执行按钮（执行某个方法或某个类）
（pycharm界面执行的方式课可以辅助调试）(右键某个文件，然后点击open in terminal 可以直接定位到文件路径)"	"【pytest命令】
安装
pip install -U pytest
查看版本
pytest --version

pytest
（无参数，读取路径下所有符合规则的文件，类，方法，函数全部执行）
-v 打印出每条用例得详细日志信息
-s 在运行结果中打印print输出的代码
-k 跳过运行某个或某些用例，试用方法如下：
-k '类名'
-k '方法名'
-k '类名 and not方法名'#运行类里所有的方法，不包含某个方法？？有点疑惑待实践确认
-x 一旦有用例失败则停止运行
--maxfail=[num] 失败个数达到阈值停止运行
-m [标记名] 将运行@pytest.mark.[标记名]这个标记的测试用例
（运行模式）
pytest 文件名.py
pytest 文件名.py::类名
pytest 文件名.py::类名::方法名

"	"【demo】
运行 pytest 收集到测试用例（当前目录下）

测试用例的识别与运行
测试文件（可执行测试文件）
test_*.py
*_test.py
用例识别（可执行测试用例）
Test*类包含的所有test_*方法（测试类不能带有_init_方法，写了代表是有特殊功能的类）
不在class中的所有test_*方法（函数）
pytest也可以执行unittest框架而写的用例和方法（规则类似）
【安装】--命令行
第三方库 pip安装，会同时安装依赖的库
pip install -U pytest 已安装升级，未安装就进行安装
vim test_a.py创建文件
pytest 运行文件
pytest -v运行时显示详细参数
如果使用Python 解释器运行需要有入口函数，没有的话就不会执行
【安装】--pycharm
创建项目，使用虚拟环境，创建Python文件test_开头
setting中tools下搜索pytest 设置Python解释器工具，将默认test解释器从默认的unittest改成pytest 并点fix安装pytest（安装完再次进入的时候，就不会有这个入口了） 或者在project解释器中添加安装
切换到pytest后想切换回Python解释器就在设置下搜索Python点击OK 就能完成切换，工作目录要确认下 有时候IDE问题 工作目录没有根据项目路径做初始化
运行时也要注意下清空历史的执行记录
使用Python解释器当pytest使用也可以 代码里加一个入口函数
if __name__ ==‘__main__’
    pytest.main('test_a.py::TestClass','-v')
两个解释器需要做一下区分
()里的参数就像命令行的参数效果一样，-v -k -k指定某个测试用例执行
pytest -k 'test_a or test_b' -v 就会执行文件名符合这两个的文件， 文件名包含的也算 参数可以看help了解
参数化--生成多条测试用例
@pytest.mark.parametrize('a,b',[(1,2),(10,20),(a,a1),(b,b1)])
def test_answer(self,a,b):
    assert func(a)==b
装饰器-部分需要登录，部分不需要登录配置
方法变成装饰器，可以将函数传入到调用的方法,有返回结果的话 返回结果也可以被返回
def login():
    username='Jerry'
    return username
class TestDemo
    def test_a(self,login):
    print(f"a username = {login}")"	"pytest框架结构
与unittest类似 执行用例前后会执行setup，teardown来增加用例的前置和后置条件（test.fixture测试装置，setup是初始化操作，teardown 清空操作避免影响后续操作）
根据用例运行级别分为以下几类：
模块级 setup_module/teardown_module
函数级 setup_function/teardown_function 只对函数用例生效（不在类中）
类级setup_class/teardown_class（只在类中前后运行一次，在类中）
方法级setup_method/teardown_method 开始于方法始末 在类中
类里面setup/teardown（运行在调用方法的前后，在类中 效果等价于setup_method 和 teardown_method）
"	"【pytest装饰器】
@pytest.mark.[标记名]
搭配pytest -m [标记名]使用 将运行有这个标记的测试用例(用例打标签进行分类)
@pytest.mark.run(order=[num])指定测试用例执行的顺序
要先安装pytest-ordering插件 pip install pytest-ordering

前置条件setup后置条件teardown调用顺序
setup_module>setup_class>setup_method>setup>teardown>teardown_method>teardown_class>teardown_module

setup_method/teardown_method 等价于setup/teardown，优先级在setup_method/teardown_method之后

@pytest.fixture 来装饰一个方法，被装饰方法的方法名可以作为一个参数传入到测试方法中（完成测试之前的初始化）"	"ini文件是项目文件 ;是注释
加了这个文件后pytest运行不会有warning ;是ini文件的注释符（我的电脑注释后不会生效？？？后续研究）

round(result,2) 取两位小数的四舍五入 避免出现0.300000004类似的情况
"
参数化用例	用测试数据构建更多测试用例	"pytest数据参数化
yaml的基本使用
--------------
参数化？
待测试的输入和输出是一组数据，可以把测试数据组织起来，用不同的测试数据调用相同的测试方法
（共同点，变化的数据变成参数的形式传入到测试用例）"	"pytest数据参数化
我们先把数据写死在pytest的文件中(如下实例)
使用：
@pytest.mark.parametrize(argnames,argvalues)
argnames:要参数化的变量，string（逗号分隔），list,tuple
argvalues:要参数化的值，list，list[tuple]
实例：
使用string
@pytest.mark.parametrize('a,b',[(1,2),(10,20)])
def test_answer(self,a,b):
    assert func(a)==b
使用list
@pytest.mark.parametrize(["a","b"],[(1,2),(10,20)])
def test_answer(self,a,b):
    assert func(a)==b

使用tuple
@pytest.mark.parametrize(("a","b"),[(1,2),(10,20)])
def test_answer(self,a,b):
    assert func(a)==b
--------
pytest参数化
-参数化装饰函数
-ids参数增加可读性(给每一条用例重新命名，没配置就会直接显示参数化的数据)

实例:
    @pytest.mark.parametrize('a,b,expect',[
        (1,1,2),
        (100,100,200),
        (0.1,0.1,0.2),
        (-1,-1,-2)
    ],ids=['int','bigint','float','minus'])"	"yaml的基本使用
数据放在yaml文件中，实现数据和py文件的分离
使用：
使用string（list和 tuple也类似做法，但方法不一样 具体见数据结构章节）
@pytest.mark.parametrize('a,b',[(1,2),(10,20)])
def test_answer(self,a,b):
    assert func(a)==b
yaml化（列表，字典，嵌套）
pytest和yaml联用方法：
yaml.safe_load(open("./data.yaml"))
#先装yaml库，加载yaml文件，加载yaml
@pytest.mark.parametrize(["a","b"],yaml.safe_load(open("./data.yaml")))
def test_answer(self,a,b):
    assert func(a)==b
-
 -10
 -20
-
 -1
 -2
encoding='utf-8'
区分变与不变的内容"
数据驱动	利用外部数据源YAML、Json、Excel、CSV管理测试	"数据驱动简介
数据驱动案例
--------------------
数据驱动？
就是数据的改变从而驱动自动化测试的执行，最终引起测试结果的改变。说的直白些，就是参数化的应用。

数据量小的测试用例可以使用代码的参数化来实现数据驱动，数据量大的情况下建议大家使用一种结构化的文件（例如 yaml,json等）来对数据进行存储，然后在测试用例中读取这些数据

（是一个概念，通过数据来驱动自动化测试的执行）"	"应用场景-自动化测试：
APP Web 接口自动化测试
测试步骤的数据驱动（如 找到id需要做什么步骤）
测试数据的数据驱动（）
配置的数据驱动（切换环境等 切换host等）

实例：
要求传的是list，如果是字典格式的化，print（env）只会打印key值(简单的解决方法是yaml文件在字典外面再嵌套一层列表，)
class TestDemo:
    @pytest.mark.parametrize("env",yaml.safe_load(open(./env.yml)))
    def test_demo(self):
        if "test"in  env:
            print("这是测试环境")
            print(env[test])#不加[]就是打印key和value，加了就直接打印value
        elif "dev"in  env:
            print("这是开发环境")
env.yml内容如下：
-
    -test:127.0.0.1
更改配置文件
-
    -dev:192.168.0.11
"	"实例踩坑

"""
这种写法load两次会导致第二次load的时候出异常
with open('./datas/calc.yaml') as f:
    adddatas = yaml.safe_load(f)['add']['datas']
    print(adddatas)
    addids = yaml.safe_load(f)['add']['myids']
    print(addids)
"""
with open('./datas/calc.yaml') as f:
    datas = yaml.safe_load(f)['add']
    adddatas = datas['datas']
    print(adddatas)
    addids = datas['myids']
    print(addids)"
测试报告美化与定制	使用最优秀的测试报告框架构建自定义测试报告	"allure介绍
allure安装
allure特性介绍
allure运行
allure报告中嵌入文本、图片、视频等资源
实战
报告测试用例 添加测试链接
添加截图等
--------------------------------------
overview（其中trend需要结合Jenkins来看）
catagories 类别
suites 测试套件（右侧展示步骤）
graphs 图表展示
timeline 时间刻度
behaviors  行为
packages 包
-----------
官网demo：https://demo.qameta.io/allure/#
总用例数，通过*失败*跳过* 结合Jenkins
为测试用例分类别--套件
趋势图 环境信息展示
左侧从各个维度看测试报告
切换中英文
suites 详情展示测试报告的信息-测试步骤、严重级别、日志、视图、截图
"	"allure介绍
allure是一个轻量级，灵活的，支持多语言的报告工具
多平台，奢华的report框架
可以为dev、qa提供详尽的测试报告、测试步骤、log
也可以为管理层提供high level统计报告（趋势图）
Java语言开发的，也支持pytest,JavaScript,PHP,ruby等
可以集成到Jenkins

allure安装
https://repo1.maven.org/maven2/io/qameta/allure/allure-commandline/
下载allure2.7.zip包
解压->进如bin目录->双击运行allure.bat
把bin目录加入PATH环境变量
Mac另外可以通过brew安装：
brew install allure

官网：http://allure.qatools.ru/（每个页面的样子。allure是基于X-unit单元测试结果的分析）
文档：https://docs.qameta.io/allure/#（各种语言可支持的单元测试框架罗列，各个平台安装方式 linux和mac是直接安装到系统目录下 所以不需要配置环境变量）
安装包linux下载tgz Windows/mac 下载zip包
allure 参数介绍
在Python环境下 安装allure-pytest 才能使用allure工具
pip install allure-pytest
运行：
 在测试执行期间收集结果
   pytest [测试文件] -s -q --alluredir=./result/(--alluredir这个选项用于指定存储测试结果得路径)
  查看测试报告
    方法一：测试完成后查看实际报告，在线看报告，会直接打开浏览器展示当前报告 allure.serve./result/ (注意这里的serve书写)
    方法二：从结果生成报告，这是一个启动tomcat的服务，生成报告，打开报告
        生成报告
            allure generate ./result/ -o./report/ --clean
        打开报告
            allure open -h 127.0.0.1 -p 8883 ./report/"	"下载：https://repo1.maven.org/maven2/io/qameta/allure/allure-commandline/
配置path
验证：控制台输入allure
（allure 要使用jdk1.8以上版本才能跑起来 ，我之前是jdk1.7 运行allure会报错）

安装allure-pytest
运行测试用例
pytest [测试文件] -s -q --alluredir=./result/(--alluredir这个选项用于指定存储测试结果的路径)

查看测试报告
方式一
allure serve ./result/
方式二
allure generate ./result/ -o./report/ --clean（注意：覆盖路径加--clean 用来清除之前生成的结果）
allure open -h 127.0.0.1 -p 8883 ./report/
服务启动后其他人就能通过“ip:端口”地址查看测试报告
"	"allure常用的特性
场景：
希望在报告中看到测试功能，子功能或场景，测试步骤，包括测试附加信息
解决：
import allure
@allure.feature('功能名称')
@allure.story('子功能名称/场景')
@allure.step('步骤细节')
@allure.attach('具体文本信息')，需要附加的信息，可以是数据，文本，图片，视频，网页
实例：见project，部分代码如下
        with allure.step("步骤1：打开应用"):
            print("打开应用")

如果只测试登录功能运行的时候可以加限制过滤：
pytest 文件名 --allure-features '购物车功能' --allure-stories'加入购物车'（注意这里 --allure-features中间是-中线）-vs(-vs是显示详细日志)
（文件名可以有多个，中间用空格隔开）
---------------------
运行实例：
步骤1 pytest test_case.py --alluredir ./reslut 收集
步骤2 allure serve ./result 查看测试报告（启动了web服务）
也可以使用allure generate ./result 生成html (自动创建allure-report文件夹，来放报告文件html,后面可以另外用Jenkins或另外启web服务来查看历史版本的报告) （IDE中右键html文件open in browser也可以查看）
allure generate ./result -o report2（想要指定其他文件路径来存放测试报告）
"	"【allure特性-step】
 测试过程中每个步骤，一般放在具体逻辑方法中
可以放在关键步骤中，在报告中显示
在app，web自动测试当中，建议每切换到一个新的页面当做一个step
用法：
@allure.step()只能以装饰器的形式放在类或者方法上面
with allure.step()可以放在测试用例方法里面，但测试步骤的代码需要被该语句包含

【allure特性-testcase】
关联测试用例（可以直接给测试用例的地址链接）（筛选比较稳定的手工测试用例来实现自动化）
实例：
    TEST_CASE_LINK = 'https://github.com/qameta/allure-integrations/issues/8#issuecomment-268313637'
    @allure.testcase(TEST_CASE_LINK,'Test case title')
    def test_with_testcase_link():
        pass
（allure套件的用例步骤详情可以点开这个链接）

【allure特性-severity】
通常测试有P0，冒烟测试，验证线上测试，按重要性级别来分别执行的，比如上线要把主流程和重要模块都跑一遍
解决：
通过附加 pytest.mark标记
通过allure.feature,allure.story
通过allure.severity来附加标记
    级别：Trivial不重要，Minor不太重要，Normal 正常问题，Critical严重，Blocker阻塞
步骤：
1、在方法，函数和类上面加
@allure.severity(allure.severity_level.TRIVIAL)
2、执行时
pytest -s -v 文件名 --allure-severities .critical

实例：pytest  文件名 --allure-severities=“critical” -vs  windows一定要用双引号
【allure特性-title】
通过@allure.title('') 给测试用例添加标题，报告中就会显示用例标题，不然就会显示用例名称
【allure特性-attach】
前端自动化测试-经常需要附加图片或html，在适当的地方，适当的时机截图 （）
解决：@allure.attach显示许多不同类型的提供的附件，可以补充测试，步骤或测试结果。
allure.attachment_type_TEXT
allure.attachment_type_HTML
allure.attachment_type_JPG PNG
allure.attachment_type_MP4
其他很多格式也可以
步骤：
在测试报告里附加网页：
语法一：
allure.attach(body(内容 文本或二进制),name,attachment_type,extension):
示例：allure.attach('<head></head><body>首页</body>','这是错误页的结果信息',allure.attachment_type_HTML)
语法二：
在测试报告里附加图片：
allure.attach.file(source,name,attachment_type,extension):
示例：
allure.attach.file("./result/b.png",attachment_type=allure.attachment_type.PNG)"	"pycharm 快捷执行参数配置：
pycharm 右上角历史执行中，可将设置参数添加参数，方便下一次执行
如 --allure-severities="trivial" -vs
后续快捷运行的时候只会执行这个级别的测试用例
需要明确的有：确定要执行的文件是否正确，添加的命令行参数是否正确，python运行环境是否正确，工作路径是否正确
-------------
Pycharm之Terminal使用
1.清屏  ------   cls   "	"

【Trivial不重要】
轻微缺陷（必输项无提示，或者提示不规范）
【Minor不太重要】
次要缺陷（界面错误与UI需求不符）
【Normal 正常问题】
普通缺陷（数值计算错误）
【Critical严重】
临界缺陷（功能点缺失）
【Blocker阻塞】
中断缺陷（客户端程序无响应，无法执行下一步操作）
# 不加任何标记,默认normal"
★实战|PythonPytest测试实战	真实项目的单元测试实战	"第一节：pytest介绍，框架结构，运行，运行参数，参数化
【pytest介绍与安装】
【pytest运行与常用运行参数】
【pytest框架结构】
【pytest参数化与数据驱动】
见理论部分
"""
以计算器实例演示如何运行单元测试框架，
作业贴 答案会公布在课程帖/作业贴
根据等价类，边界值，因果图测试方法补充测试用例
测试用例中添加断言，验证结果
灵活使用setup(),teardown(),set_class(),teardown_class()
"""
"	"第二节：pytest fixture高级用法，conftest.py用法，pytest配置执行规则

【pytest fixture高级用法】
fixture是在测试函数运行前后，由pytest执行的外壳函数：可编写代码实现不同功能，满足多变的需求，作用：接口测试（如需要不同的数据源，动态传入数据集）、测试前初始化配置（如连接数据库，打开APP，打开web）为批量数据提供数据源等
fixture是pytest用于将测试前后进行预备，清理工作的代码分离出核心测试逻辑的一种机制
@pytest.fixture 来装饰一个方法，被装饰方法的方法名可以作为一个参数传入到测试方法中（完成测试之前的初始化）
用法
-为测试用例的执行、初始化一些数据和方法：
1、类似setUp,tearDown功能，但比setUp,tearDown更灵活
2、直接通过函数名调用或使用装饰器@pytest.mark.usefixtures('test1')
3、允许使用多个Fixture（允许调用多个）
4、使用autouse自动应用，如果要返回值，需要传fixture函数名
5、作用域（session>module>class>function）
--setup-show回溯fixture的执行过程。fixture的 scope（范围）参数默认是function
-function 函数或者方法级别都会被调用
-class 类级别调用一次
-module 模块级别调用一次（每个.py文件就是module）
-session是多个文件调用一次（课可以跨.py文件调用）
tips：作用域为session class 用例没传递装饰器的时候也能跑，但至少用要传递一次，最好是传递在第一个方法上，但从哪个方法开始传就从哪个方法开始调用"	"场景一：前端自动化中应用
测试用例执行时，有的用例需要登录，有的不需要登录。setup和teardown无法满足。Fixture可以。
步骤：
1、导入pytest
2、在登录的函数上面加@pytest.fixture() (即创建一个登录的fixture方法)
3、在要使用的测试方法中传入（登录函数名称）、就先登录
4、不传入的就不登录直接执行测试方法。
场景二：前端自动化中的应用-yield
你已经可以将测试方法要执行的或依赖的解决了，测试方法后销毁清除数据的要如何进行呢？范围是模块界别的。类似setClass --？？这边的描述准确吗？
解决：
通过在同一模块中加入yield关键字，yield是调用第一次返回结果，第二次执行它下面的语句返回。在@pytest.fixture(scope=module)
在登录的方法中加yield，之后加销毁清除的步骤

(  # yield 关键字激活了fixture的teardown方法,yield是一个生成器，如文件很大，要读取的时候需要使用生成器来一行一行读取。它不能直接获取，只能通过 next()来获取生成器里面的下一个值)
简单地讲，yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。

yield生成器实例：
def provider():
    for i in range(0,10):
        print("开始操作")
        yield i #相当于return i
        print("结束操作")
p = provider()
print(p) #这样只能打印出生成器的对象
print(next(p)) #0
print(next(p)) #1

开始操作
0
结束操作
开始操作
1
------
# 创建一个登录的fixture方法，yield 关键字激活了fixture 的 teardown 方法
# fixture 是pytest的外壳函数，可以模拟setup，teardown 操作
# yield 之前的操作相当于setup ， yield 之后的操作相当于teardown
# yield 相当于return ,如果想要return一些测试数据，可以放在yield后面返回到测试用例中。
其实是对生成器的封装，有做了简单的处理
场景三：前端自动化中的应用-autouse（针对所有测试用例，不建议使用 所有用例都会加，但常常被使用）
不想原测试方法有任何改动，或全部都自动实现自动应用，没特例，也都不需要返回值时可以选择自动应用
解决
使用fixture中参数autouse=True实现
步骤
在方法上面加@pytest.fixture(autouse=True)
"	"场景：fixture带参数传递 -params ids
测试离不开数据，为了数据灵活，一般数据都是通过参数传的
解决：fixture通过固定参数request传递；
步骤：在fixture中添加@pytest.fixture(params=[1,2,3,'linda'])在方法参数写request
实例
@pytest.fixture(params=[1,2,3],ids=['result1','result2','result3'])
def test_data(request):
    return request.param

class TestDemo:
    def test_one(self,test_data):
     print("\n test data:%s"% test_data)
---------
@pytest.fixture(params=adddatas,ids=addids)
def get_datas(request):
    data=request.param
    print(f"request.param的测试数据是：{data}")
    return data
--------
fixture的参数化和Parameterize参数话都可以，哪个比较熟悉就用哪个
    def test_add1(self,get_calc,get_datas):fixture可以使用多个，会先执行前面的后执行后面的，所以要注意下顺序"	"【conftest.py用法】
fixture很好用，可以有很多个，同时很多地方在用，所以就统一放在这个公共的地方供大家调用
场景：前段自动化中的应用-conftest
与其他测试工程师合作一起开发，公共的模块要在不同文件中，要在大家都访问的到的地方
解决：使用conftest.py这个文件进行数据共享，并且他可以放在不同位置 起着不同的范围共享作用
前提：conftest.py文件名不能换，放在项目下是全局的数据共享的地方全局的配置和前期工作都可以写在这里，放在某个包下（必须有__intit__.py文件），就是这个包数据共享的地方
执行：系统执行到参数login（装饰器函数）时，先从你本文件（优先读取自己的）中查找是否有这个名字的fixture方法，没找到之后在conftest.py中找是否有。
步骤：
将登陆模块带@pytest.fixture写在conftest.py
用例中不需要导入就能使用fixture函数
结合scope使用
后面讲的hook函数也可以配置在conftest.py这边调用"	"【pytest配置】
pytest的配置文件
pytest.ini  用的比较多
---另外tox.ini setp.cfg都是配置文件

pytest --help  命令查看介绍

配置文件可以定义的内容
markers 自定义mark标签名
addopts 运行时参数（可添加多个命令行参数，空格分隔，所有参数和命令行一致）
python_files 自定义测试文件命名规则
python_classes = Test_* 自定义测试类命名规则
python_functions = test_*check_* 自定义测试方法命名规则
testpaths = testdemo bilibili baidu指定路径执行
norecursedirs = result logs datas test_demo*运行时忽略某些文件夹（配置完可以提高运行效率，比如直接忽略缓存文件 报告文件）
-----
cmzhu:ini文件的备注使用分号 但是注释使用中文运行时会提示编码问题--头部加上#coding=utf-8 好像也解决不了 老师的电脑可以有中文备注的"	"第三节：pytest常用插件，pytest hook函数，Allure用法
【pytest常用插件】

【pytest hook函数】

【Allure用法】
"	"简单的判断可以放在setup或测试用例里，不要做太多的判断

文档左上角的注释是在setting中设置的 显示环境和编码

token是完成登录之后，服务器返回的token码，用于后续通讯 token和cookie在接口章节介绍
-------------------------
git 对勾标志是commit操作 备注 最好配上格式化代码
vcs-git-push推到远程代码库
"	"标题
python pytest 测试实战1

课程价值
理解 pytest 框架结构
掌握运行及常用的运行参数
掌握参数化与数据驱动
大纲
pytest 介绍与安装
pytest 运行
pytest 框架结构
pytest 参数化

实战内容
参考资料

pytest 官网：http://www.pytest.org/ 11
pytest 安装
安装命令
pip install pytest
版本验证
pytest --version
pycharm 配置
进入 pycharm 设置
搜索 pytest
设置 test runner
image
image
2038×596 74.5 KB
删除 pycharm 运行记录
image
image
1032×566 78.2 KB
pytest 运行
pytest 规则
测试文件、测试函数、测试方法，名称需要以 test_ 开头
测试类名称需要 Test 开头
测试类中不能包含 init 方法
pycharm 中运行
运行整个测试文件：在文件上点击鼠标右键，选择 run
点击绿色小三角，运行对应的测试类或者测试方法
命令行运行
运行当前目录下所有测试文件：pytest
运行指定的测试文件：pytest 文件名
运行指定文件中的指定的类或者方法：pytest 文件名::测试类名::测试方法名
查看执行过程中的详细信息和打印信息：pytest -vs
只收集测试用例不运行：pytest --collect-only
生成执行结果文件：pytest --junitxml=./result.xml

pytest 框架结构
模块级(setup_module/teardown_module)模块始末，全局的（优先最高）
函数级(setup_function/teardown_function)只对函数用例生效(不在类中)
类级(setup_class/teardown_class)只在类中前后运行一次（在类中）
方法级(setup_method/teardown_methond)开始于方法始末（在类中）
类里面的（setup/teardown）运行在调用方法的前后
参数化
单个参数化：参数名称写在字符串中，参数值用列表传递
多个参数：参数名称写在字符串中，参数值用列表套列表或者元组的方式传递
测试用例起别名：ids=
笛卡尔积：用两个装饰器分别传入参数
从 yaml 中读取参数：数据读取成为参数化中需要的参数格式
课后作业
补全计算器中加法和除法的测试用例
使用参数化完成测试用例的自动生成
在调用测试方法之前打印【开始计算】，在调用测试方法之后打印【计算结束】
注意：

使用等价类，边界值，因果图等设计测试用例
测试用例中添加断言，验证结果
灵活使用 setup(), teardown() , setup_class(), teardown_class()
"	"标题
python pytest 测试实战2

课程价值
掌握 pytest fixture 用法
掌握 pytest 常用插件
掌握 allure
了解 pytest hook 函数
大纲
pytest fixture 高级用法
conftest.py 用法
pytest 配置
pytest 常用插件
allure 生成测试报告
pytest hook 函数

实战内容
参考资料

allure 下载： https://repo1.maven.org/maven2/io/qameta/allure/allure-commandline/2.13.7/ 14
hook 函数：https://docs.pytest.org/en/latest/_modules/_pytest/hookspec.html 13
fixture
定义
@pytest.fixture()
def fixture_method():
    print("setup 操作")
    yield
    print("teardown 操作")
调用方式
测试用例中传入 fixture 方法名
@pytest.mark.usefixtures("fixture 方法名")
自动调用 @pytest.fixture(autouse=True)
作用域
控制方法：@pytest.fixture(scope="")
scope 的取值
function 默认值
class
module
session
fixture 方法返回值获取
把返回值写到 fixture 方法的 yield 后面
在测试用例中使用 fixture 方法名获取返回值
conftest.py 用法
conftest.py 文件名是不能改变的
conftest.py 和要运行的用例需要在同一个包下面
conftest.py 生效遵循就近原则
pytest 配置
写在 pytest.ini 文件中
pytest 的主配置文件，一般放在项目工程的根目录
指定 pytest 的运行方式
不能使用任何中文符号
[pytest]
markers = add
          div
          sub
          mul

;运行时的参数
addopts = -vs

;自定义测试文件命名规则
;python_files =  check_* test_*
;自定义测试类命名规则
;python_classes = Check* Test*
;自定义测试方法命名规则
;python_functions= test_* check_*

; 指定执行路径
testpaths = sub_demo
; 忽略路径
norecursedirs = datas
pytest 常用插件
pip install pytest-rerunfailures 失败重跑
pip install pytest-assume 多重较验
pip install pytest-ordering 控制用例的执行顺序
pip install pytest-xdist 分布式并发执行测试用例
pip install pytest-html 测试报告
pip install pytest-sugar 命令行显示美化

allure 生成测试报告
安装

本地工具安装：下载zip包，解压zip包，把 bin 目录配置到环境变量
安装 pytest 插件：pip install allure-pytest
用法
生成 allure 测试结果：pytest —alluredir=./result
展示报告：allure serve ./result
生成最终版本的报告：allure generate ./result
清除上一次的记录：allure generate result --clean result/html -o result/html
打开报告：allure open -h 127.0.0.1 -p 8883 ./result/
pytest hook 函数
hook 函数定义在 conftest.py 文件中
pytest_collection_modifyitems 收集上来的测试用例实现定制化功能
课后作业
补全计算器（加减乘除）的测试用例
使用数据的数据驱动，完成加减乘除用例的自动生成
创建 fixture 方法实现执行测试用例前打印【开始计算】，执行测试用例之后打印【计算结束】
控制测试用例顺序按照【加-减-乘-除】这个顺序执行
结合allure 生成测试结果报告"
